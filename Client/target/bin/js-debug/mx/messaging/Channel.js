/**
 * Generated by Apache Royale Compiler from mx/messaging/Channel.as
 * mx.messaging.Channel
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.messaging.Channel');
/* Royale Dependency List: XML,XMLList,mx.collections.ArrayCollection,mx.core.mx_internal,mx.errors.IllegalOperationError,mx.events.PropertyChangeEvent,mx.logging.ILogger,mx.logging.Log,mx.messaging.ChannelSet,mx.messaging.MessageAgent,mx.messaging.RoyaleClient,mx.messaging.config.LoaderConfig,mx.messaging.config.ServerConfig,mx.messaging.errors.InvalidChannelError,mx.messaging.errors.InvalidDestinationError,mx.messaging.events.ChannelEvent,mx.messaging.events.ChannelFaultEvent,mx.messaging.messages.AbstractMessage,mx.messaging.messages.CommandMessage,mx.messaging.messages.ErrorMessage,mx.messaging.messages.IMessage,mx.resources.IResourceManager,mx.resources.ResourceManager,mx.rpc.AsyncDispatcher,mx.utils.URLUtil,org.apache.royale.events.Event,org.apache.royale.reflection.getDefinitionByName,org.apache.royale.utils.Timer,org.apache.royale.utils.Language*/
goog.provide('mx.messaging.Channel.AuthenticationMessageResponder');

goog.require('mx.messaging.MessageResponder');
goog.require('org.apache.royale.events.EventDispatcher');
goog.require('mx.core.IMXMLObject');



/**
 *  Constructs an instance of a generic Channel that connects to the
 *  specified endpoint URI.
 *
 *  <b>Note</b>: The Channel type should not be constructed directly. Instead
 *  create instances of protocol specific subclasses such as RTMPChannel or
 *  AMFChannel.
 *
 *  @asparam id The id of this channel.
 * 
 *  @asparam uri The endpoint URI for this channel.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3      
 * @constructor
 * @extends {org.apache.royale.events.EventDispatcher}
 * @implements {mx.core.IMXMLObject}
 * @param {string=} id
 * @param {string=} uri
 */
mx.messaging.Channel = function(id, uri) {
  id = typeof id !== 'undefined' ? id : null;
  uri = typeof uri !== 'undefined' ? uri : null;
  
  this.mx_messaging_Channel_resourceManager = mx.resources.ResourceManager.getInstance();
  this.mx_messaging_Channel__channelSets = [];
  mx.messaging.Channel.base(this, 'constructor');
  this._log = mx.logging.Log.getLogger("mx.messaging.Channel");
  this.mx_messaging_Channel__failoverIndex = -1;
  this.id = id;
  this.mx_messaging_Channel__primaryURI = uri;
  this.uri = uri;
};
goog.inherits(mx.messaging.Channel, org.apache.royale.events.EventDispatcher);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.Channel', mx.messaging.Channel);


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.CLIENT_LOAD_BALANCING = "client-load-balancing";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.CONNECT_TIMEOUT_SECONDS = "connect-timeout-seconds";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.ENABLE_SMALL_MESSAGES = "enable-small-messages";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.FALSE = "false";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.RECORD_MESSAGE_TIMES = "record-message-times";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.RECORD_MESSAGE_SIZES = "record-message-sizes";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.REQUEST_TIMEOUT_SECONDS = "request-timeout-seconds";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.SERIALIZATION = "serialization";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.TRUE = "true";


/**
 * @asprivate
 * @export
 * @param {Object} document
 * @param {string} id
 */
mx.messaging.Channel.prototype.initialized = function(document, id) {
  this.id = id;
};


/**
 * @type {boolean}
 */
mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__authenticating;


/**
 * @export
 * @type {string}
 */
mx.messaging.Channel.prototype.credentials;


/**
 * @export
 * @type {boolean}
 */
mx.messaging.Channel.prototype.enableSmallMessages = true;


/**
 * @export
 * @type {mx.logging.ILogger}
 */
mx.messaging.Channel.prototype._log;


/**
 * @export
 * @type {boolean}
 */
mx.messaging.Channel.prototype._connecting;


/**
 * @private
 * @type {org.apache.royale.utils.Timer}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__connectTimer;


/**
 * @private
 * @type {number}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__failoverIndex = 0;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__isEndpointCalculated;


/**
 * @export
 * @type {number}
 */
mx.messaging.Channel.prototype.messagingVersion = 1.0;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__ownsWaitGuard;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__previouslyConnected;


/**
 * @private
 * @type {string}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__primaryURI;


/**
 * @type {number}
 */
mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration = -1;


/**
 * @private
 * @type {number}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__reliableReconnectBeginTimestamp;


/**
 * @private
 * @type {number}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__reliableReconnectLastTimestamp;


/**
 * @private
 * @type {number}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__reliableReconnectAttempts = 0;


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_resourceManager;


/**
 * @private
 * @type {Array}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__channelSets;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__connected = false;


/**
 *  @asprivate
 * @export
 * @param {boolean} value
 */
mx.messaging.Channel.prototype.setConnected = function(value) {
  if (this.mx_messaging_Channel__connected != value) {
    if (this.mx_messaging_Channel__connected)
      this.mx_messaging_Channel__previouslyConnected = true;
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "connected", this.mx_messaging_Channel__connected, value);
    this.mx_messaging_Channel__connected = value;
    this.dispatchEvent(event);
    if (!value)
      this.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated(false);
  }
};


/**
 * @private
 * @type {number}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__connectTimeout = -1;


/**
 * @private
 * @type {string}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__endpoint;


/**
 * @export
 * @type {boolean}
 */
mx.messaging.Channel.prototype._recordMessageTimes = false;


/**
 * @export
 * @type {boolean}
 */
mx.messaging.Channel.prototype._recordMessageSizes = false;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__reconnecting = false;


/**
 * @private
 * @param {boolean} value
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_setReconnecting = function(value) {
  if (this.mx_messaging_Channel__reconnecting != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "reconnecting", this.mx_messaging_Channel__reconnecting, value);
    this.mx_messaging_Channel__reconnecting = value;
    this.dispatchEvent(event);
  }
};


/**
 * @private
 * @type {Array}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__failoverURIs;


/**
 * @private
 * @type {string}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__id;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__authenticated = false;


/**
 * @export
 * @param {boolean} value
 */
mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated = function(value) {
  if (value != this.mx_messaging_Channel__authenticated) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "authenticated", this.mx_messaging_Channel__authenticated, value);
    this.mx_messaging_Channel__authenticated = value;
    var /** @type {mx.messaging.ChannelSet} */ cs;
    for (var /** @type {number} */ i = 0; i < this.mx_messaging_Channel__channelSets.length; i++) {
      cs = org.apache.royale.utils.Language.as(this.mx_messaging_Channel__channelSets[i], mx.messaging.ChannelSet, true);
      cs[new QName(mx.core.mx_internal, 'setAuthenticated').objectAccessFormat()](this.authenticated, this.credentials);
    }
    this.dispatchEvent(event);
  }
};


/**
 * @private
 * @type {number}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__requestTimeout = -1;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__shouldBeConnected;


/**
 * @private
 * @type {string}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__uri;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel__smallMessagesSupported;


/**
 *  Subclasses should override this method to apply any settings that may be
 *  necessary for an individual channel.
 *  Make sure to call <code>super.applySettings()</code> to apply common settings for the channel. * *  This method is used primarily in Channel subclasses.
 *
 *  @asparam settings XML fragment of the services-config.xml file for this channel.
 * @export
 * @param {XML} settings
 */
mx.messaging.Channel.prototype.applySettings = function(settings) {
  if (mx.logging.Log.isInfo())
    this._log.info("'{0}' channel settings are:\n{1}", this.id, settings);
  if (settings.child('properties').length() == 0)
    return;
  var /** @type {XML} */ props = settings.child('properties')[0];
  this.applyClientLoadBalancingSettings(props);
  if (props.child(mx.messaging.Channel.CONNECT_TIMEOUT_SECONDS).length() != 0)
    this.connectTimeout = (props.child(mx.messaging.Channel.CONNECT_TIMEOUT_SECONDS).toString()) >> 0;
  if (props.child(mx.messaging.Channel.RECORD_MESSAGE_TIMES).length() != 0)
    this._recordMessageTimes = props.child(mx.messaging.Channel.RECORD_MESSAGE_TIMES).toString() == mx.messaging.Channel.TRUE;
  if (props.child(mx.messaging.Channel.RECORD_MESSAGE_SIZES).length() != 0)
    this._recordMessageSizes = props.child(mx.messaging.Channel.RECORD_MESSAGE_SIZES).toString() == mx.messaging.Channel.TRUE;
  if (props.child(mx.messaging.Channel.REQUEST_TIMEOUT_SECONDS).length() != 0)
    this.requestTimeout = (props.child(mx.messaging.Channel.REQUEST_TIMEOUT_SECONDS).toString()) >> 0;
  var /** @type {XMLList} */ serializationProps = props.child(mx.messaging.Channel.SERIALIZATION);
  if (serializationProps.length() != 0 && serializationProps.child(mx.messaging.Channel.ENABLE_SMALL_MESSAGES).toString() == mx.messaging.Channel.FALSE)
    this.enableSmallMessages = false;
};


/**
 *  Applies the client load balancing urls if they exists. It randomly picks
 *  a url from the set of client load balancing urls and sets it as the channel's
 *  main url; then it assigns the rest of the urls as the <code>failoverURIs</code>
 *  of the channel.
 *
 *  @asparam props The properties section of the XML fragment of the services-config.xml
 *  file for this channel.
 * @export
 * @param {XML} props
 */
mx.messaging.Channel.prototype.applyClientLoadBalancingSettings = function(props) {
  var /** @type {XMLList} */ clientLoadBalancingProps = props.child(mx.messaging.Channel.CLIENT_LOAD_BALANCING);
  if (clientLoadBalancingProps.length() == 0)
    return;
  var /** @type {number} */ urlCount = (clientLoadBalancingProps.child('url').length()) >> 0;
  if (urlCount == 0)
    return;
  var /** @type {Array} */ urls = [];
  var foreachiter0_target = clientLoadBalancingProps.child('url');
  for (var foreachiter0 in foreachiter0_target.elementNames()) 
  {
  var url = foreachiter0_target[foreachiter0];
  
    urls.push(url.toString());}
  
  this.mx_messaging_Channel_shuffle(urls);
  if (mx.logging.Log.isInfo())
    this._log.info("'{0}' channel picked {1} as its main url.", this.id, urls[0]);
  this.url = org.apache.royale.utils.Language.string(urls[0]);
  var /** @type {Array} */ failoverURIs = urls.slice(1);
  if (failoverURIs.length > 0)
    this.failoverURIs = failoverURIs;
};


/**
 *  Connects the ChannelSet to the Channel. If the Channel has not yet
 *  connected to its endpoint, it attempts to do so.
 *  Channel subclasses must override the <code>internalConnect()</code> 
 *  method, and call the <code>connectSuccess()</code> method once the
 *  underlying connection is established.
 * 
 *  @asparam channelSet The ChannelSet to connect to the Channel.
 * @export
 * @param {mx.messaging.ChannelSet} channelSet
 */
mx.messaging.Channel.prototype.connect = function(channelSet) {
  var /** @type {boolean} */ exists = false;
  var /** @type {number} */ n = (this.mx_messaging_Channel__channelSets.length) >> 0;
  for (var /** @type {number} */ i = 0; i < this.mx_messaging_Channel__channelSets.length; i++) {
    if (this.mx_messaging_Channel__channelSets[i] == channelSet) {
      exists = true;
      break;
    }
  }
  this.mx_messaging_Channel__shouldBeConnected = true;
  if (!exists) {
    this.mx_messaging_Channel__channelSets.push(channelSet);
    this.addEventListener(mx.messaging.events.ChannelEvent.CONNECT, org.apache.royale.utils.Language.closure(channelSet.channelConnectHandler, channelSet, 'channelConnectHandler'));
    this.addEventListener(mx.messaging.events.ChannelEvent.DISCONNECT, org.apache.royale.utils.Language.closure(channelSet.channelDisconnectHandler, channelSet, 'channelDisconnectHandler'));
    this.addEventListener(mx.messaging.events.ChannelFaultEvent.FAULT, org.apache.royale.utils.Language.closure(channelSet.channelFaultHandler, channelSet, 'channelFaultHandler'));
  }
  if (this.connected) {
    channelSet.channelConnectHandler(mx.messaging.events.ChannelEvent.createEvent(mx.messaging.events.ChannelEvent.CONNECT, this, false, false, this.connected));
  } else if (!this._connecting) {
    this._connecting = true;
    if (this.connectTimeout > 0) {
      this.mx_messaging_Channel__connectTimer = new org.apache.royale.utils.Timer(this.connectTimeout * 1000, 1);
      this.mx_messaging_Channel__connectTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.connectTimeoutHandler, this, 'connectTimeoutHandler'));
      this.mx_messaging_Channel__connectTimer.start();
    }
    if (mx.messaging.RoyaleClient.getInstance().id == null) {
      var /** @type {mx.messaging.RoyaleClient} */ royaleClient = mx.messaging.RoyaleClient.getInstance();
      if (!royaleClient.http_$$www_adobe_com$2006$flex$mx$internal__waitForRoyaleClientId) {
        royaleClient.http_$$www_adobe_com$2006$flex$mx$internal__waitForRoyaleClientId = true;
        this.mx_messaging_Channel__ownsWaitGuard = true;
        this.internalConnect();
      } else {
        royaleClient.addEventListener(mx.events.PropertyChangeEvent.PROPERTY_CHANGE, org.apache.royale.utils.Language.closure(this.royaleClientWaitHandler, this, 'royaleClientWaitHandler'));
      }
    } else {
      this.internalConnect();
    }
  }
};


/**
 *  Disconnects the ChannelSet from the Channel. If the Channel is connected
 *  to its endpoint and it has no more connected ChannelSets it will 
 *  internally disconnect.
 *
 *  <p>Channel subclasses need to override the 
 *  <code>internalDisconnect()</code> method, and call the
 *  <code>disconnectSuccess()</code> method when the underlying connection
 *  has been terminated.</p>
 * 
 *  @asparam channelSet The ChannelSet to disconnect from the Channel.
 * @export
 * @param {mx.messaging.ChannelSet} channelSet
 */
mx.messaging.Channel.prototype.disconnect = function(channelSet) {
  if (this.mx_messaging_Channel__ownsWaitGuard) {
    this.mx_messaging_Channel__ownsWaitGuard = false;
    mx.messaging.RoyaleClient.getInstance().http_$$www_adobe_com$2006$flex$mx$internal__waitForRoyaleClientId = false;
  }
  var /** @type {number} */ i = (channelSet != null ? this.mx_messaging_Channel__channelSets.indexOf(channelSet) : -1) >> 0;
  if (i != -1) {
    this.mx_messaging_Channel__channelSets.splice(i, 1);
    this.removeEventListener(mx.messaging.events.ChannelEvent.CONNECT, org.apache.royale.utils.Language.closure(channelSet.channelConnectHandler, channelSet, 'channelConnectHandler'), false);
    this.removeEventListener(mx.messaging.events.ChannelEvent.DISCONNECT, org.apache.royale.utils.Language.closure(channelSet.channelDisconnectHandler, channelSet, 'channelDisconnectHandler'), false);
    this.removeEventListener(mx.messaging.events.ChannelFaultEvent.FAULT, org.apache.royale.utils.Language.closure(channelSet.channelFaultHandler, channelSet, 'channelFaultHandler'), false);
    if (this.connected) {
      channelSet.channelDisconnectHandler(mx.messaging.events.ChannelEvent.createEvent(mx.messaging.events.ChannelEvent.DISCONNECT, this, false));
    }
    if (this.mx_messaging_Channel__channelSets.length == 0) {
      this.mx_messaging_Channel__shouldBeConnected = false;
      if (this.connected)
        this.internalDisconnect();
    }
  }
};


/**
 *  Sends a CommandMessage to the server to logout if the Channel is connected.
 *  Current credentials are cleared.
 * 
 *  @asparam agent The MessageAgent to logout.
 * @export
 * @param {mx.messaging.MessageAgent} agent
 */
mx.messaging.Channel.prototype.logout = function(agent) {
  if ((this.connected && this.authenticated && this.credentials) || (this.http_$$www_adobe_com$2006$flex$mx$internal__authenticating && this.credentials)) {
    var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
    msg.operation = mx.messaging.messages.CommandMessage.LOGOUT_OPERATION;
    this.internalSend(new mx.messaging.Channel.AuthenticationMessageResponder(agent, msg, this, this._log));
    this.http_$$www_adobe_com$2006$flex$mx$internal__authenticating = true;
  }
  this.credentials = null;
};


/**
 *  Sends the specified message to its target destination.
 *  Subclasses must override the <code>internalSend()</code> method to
 *  perform the actual send.
 *
 *  @asparam agent The MessageAgent that is sending the message.
 * 
 *  @asparam message The Message to send.
 * 
 *  @throws mx.messaging.errors.InvalidDestinationError If neither the MessageAgent nor the
 *                                  message specify a destination.
 * @export
 * @param {mx.messaging.MessageAgent} agent
 * @param {mx.messaging.messages.IMessage} message
 */
mx.messaging.Channel.prototype.send = function(agent, message) {
  if (message.destination.length == 0) {
    if (agent.destination.length == 0) {
      var /** @type {string} */ msg = this.mx_messaging_Channel_resourceManager.getString("messaging", "noDestinationSpecified");
      throw new mx.messaging.errors.InvalidDestinationError(msg);
    }
    message.destination = agent.destination;
  }
  if (mx.logging.Log.isDebug())
    this._log.debug("'{0}' channel sending message:\n{1}", this.id, message.toString());
  message.headers[mx.messaging.messages.AbstractMessage.ENDPOINT_HEADER] = this.id;
  var /** @type {mx.messaging.MessageResponder} */ responder = this.getMessageResponder(agent, message);
  this.mx_messaging_Channel_initializeRequestTimeout(responder);
  this.internalSend(responder);
};


/**
 *  Sets the credentials to the specified value. 
 *  If the credentials are non-null and the Channel is connected, this method also
 *  sends a CommandMessage to the server to login using the credentials.
 * 
 *  @asparam credentials The credentials string.
 *  @asparam agent The MessageAgent to login, that will handle the login result.
 *  @asparam charset The character set encoding used while encoding the
 *  credentials. The default is null, which implies the legacy charset of
 *  ISO-Latin-1.
 *
 *  @throws flash.errors.IllegalOperationError in two situations; if credentials
 *  have already been set and an authentication is in progress with the remote
 *  detination, or if authenticated and the credentials specified don't match
 *  the currently authenticated credentials.
 * @export
 * @param {string} credentials
 * @param {mx.messaging.MessageAgent=} agent
 * @param {string=} charset
 */
mx.messaging.Channel.prototype.setCredentials = function(credentials, agent, charset) {
  agent = typeof agent !== 'undefined' ? agent : null;
  charset = typeof charset !== 'undefined' ? charset : null;
  var /** @type {boolean} */ changedCreds = this.credentials !== credentials;
  if (this.http_$$www_adobe_com$2006$flex$mx$internal__authenticating && changedCreds)
    throw new mx.errors.IllegalOperationError("Credentials cannot be set while authenticating or logging out.");
  if (this.authenticated && changedCreds)
    throw new mx.errors.IllegalOperationError("Credentials cannot be set when already authenticated. Logout must be performed before changing credentials.");
  this.credentials = credentials;
  if (this.connected && changedCreds && credentials != null) {
    this.http_$$www_adobe_com$2006$flex$mx$internal__authenticating = true;
    var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
    msg.operation = mx.messaging.messages.CommandMessage.LOGIN_OPERATION;
    msg.body = credentials;
    if (charset != null)
      msg.headers[mx.messaging.messages.CommandMessage.CREDENTIALS_CHARSET_HEADER] = charset;
    this.internalSend(new mx.messaging.Channel.AuthenticationMessageResponder(agent, msg, this, this._log));
  }
};


/**
 *  @asprivate
 *  Internal hook for ChannelSet to assign credentials when it has authenticated
 *  successfully via a direct <code>login(...)</code> call to the server.
 * @export
 * @param {string} credentials
 */
mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__internalSetCredentials = function(credentials) {
  this.credentials = credentials;
};


/**
 *  @asprivate
 *  This is a hook for ChannelSet (not a MessageAgent) to send internal messages. 
 *  This is used for fetching info on clustered endpoints for a clustered destination
 *  as well as for optional heartbeats, etc.
 * 
 *  @asparam msgResp The message responder to use for the internal message.
 * @export
 * @param {mx.messaging.MessageResponder} msgResp
 */
mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__sendInternalMessage = function(msgResp) {
  this.internalSend(msgResp);
};


/**
 *  Processes a failed internal connect and dispatches the 
 *  <code>FAULT</code> event for the channel.
 *  If the Channel has <code>failoverURI</code> values, it will
 *  attempt to reconnect automatically by trying these URI values in order until 
 *  a connection is established or the available values are exhausted.
 * 
 *  @asparam event The ChannelFaultEvent for the failed connect.
 * @export
 * @param {mx.messaging.events.ChannelFaultEvent} event
 */
mx.messaging.Channel.prototype.connectFailed = function(event) {
  this.mx_messaging_Channel_shutdownConnectTimer();
  this.setConnected(false);
  if (mx.logging.Log.isError())
    this._log.error("'{0}' channel connect failed.", this.id);
  if (!event.rejected && this.mx_messaging_Channel_shouldAttemptFailover()) {
    this._connecting = true;
    this.mx_messaging_Channel_failover();
  } else {
    this.mx_messaging_Channel_connectCleanup();
  }
  if (this.reconnecting)
    event.reconnecting = true;
  this.dispatchEvent(event);
};


/**
 *  Processes a successful internal connect and dispatches the 
 *  <code>CONNECT</code> event for the Channel.
 * @export
 */
mx.messaging.Channel.prototype.connectSuccess = function() {
  this.mx_messaging_Channel_shutdownConnectTimer();
  if (mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__fetchedConfig(this.endpoint)) {
    for (var /** @type {number} */ i = 0; i < this.channelSets.length; i++) {
      var /** @type {Array} */ messageAgents = org.apache.royale.utils.Language.as(this.channelSets[i], mx.messaging.ChannelSet, true).messageAgents;
      for (var /** @type {number} */ j = 0; j < messageAgents.length; j++) {
        messageAgents[j].needsConfig = false;
      }
    }
  }
  this.setConnected(true);
  this.mx_messaging_Channel__failoverIndex = -1;
  if (mx.logging.Log.isInfo())
    this._log.info("'{0}' channel is connected.", this.id);
  this.dispatchEvent(mx.messaging.events.ChannelEvent.createEvent(mx.messaging.events.ChannelEvent.CONNECT, this, this.reconnecting));
  this.mx_messaging_Channel_connectCleanup();
};


/**
 *  Handles a connect timeout by dispatching a ChannelFaultEvent. 
 *  Subtypes may overide this to shutdown the current connect attempt but must 
 *  call <code>super.connectTimeoutHandler(event)</code>.
 * 
 *  @asparam event The timer event indicating that the connect timeout has been reached.
 * @export
 * @param {org.apache.royale.events.Event} event
 */
mx.messaging.Channel.prototype.connectTimeoutHandler = function(event) {
  this.mx_messaging_Channel_shutdownConnectTimer();
  if (!this.connected) {
    this.mx_messaging_Channel__shouldBeConnected = false;
    var /** @type {string} */ errorText = this.mx_messaging_Channel_resourceManager.getString("messaging", "connectTimedOut");
    var /** @type {mx.messaging.events.ChannelFaultEvent} */ faultEvent = mx.messaging.events.ChannelFaultEvent.createEvent(this, false, "Channel.Connect.Failed", "error", errorText);
    this.connectFailed(faultEvent);
  }
};


/**
 *  Processes a successful internal disconnect and dispatches the 
 *  <code>DISCONNECT</code> event for the Channel.
 *  If the disconnect is due to a network failure and the Channel has 
 *  <code>failoverURI</code> values, it will attempt to reconnect automatically 
 *  by trying these URI values in order until a connection is established or the 
 *  available values are exhausted.
 *  
 *  @asparam rejected True if the disconnect should skip any
 *         failover processing that would otherwise be attempted; false
 *         if failover processing should be allowed to run.
 * @export
 * @param {boolean=} rejected
 */
mx.messaging.Channel.prototype.disconnectSuccess = function(rejected) {
  rejected = typeof rejected !== 'undefined' ? rejected : false;
  this.setConnected(false);
  if (mx.logging.Log.isInfo())
    this._log.info("'{0}' channel disconnected.", this.id);
  if (!rejected && this.mx_messaging_Channel_shouldAttemptFailover()) {
    this._connecting = true;
    this.mx_messaging_Channel_failover();
  } else {
    this.mx_messaging_Channel_connectCleanup();
  }
  this.dispatchEvent(mx.messaging.events.ChannelEvent.createEvent(mx.messaging.events.ChannelEvent.DISCONNECT, this, this.reconnecting, rejected));
};


/**
 *  Processes a failed internal disconnect and dispatches the
 *  <code>FAULT</code> event for the channel.
 * 
 *  @asparam event The ChannelFaultEvent for the failed disconnect.
 * @export
 * @param {mx.messaging.events.ChannelFaultEvent} event
 */
mx.messaging.Channel.prototype.disconnectFailed = function(event) {
  this._connecting = false;
  this.setConnected(false);
  if (mx.logging.Log.isError())
    this._log.error("'{0}' channel disconnect failed.", this.id);
  if (this.reconnecting) {
    this.mx_messaging_Channel_resetToPrimaryURI();
    event.reconnecting = false;
  }
  this.dispatchEvent(event);
};


/**
 *  Handles a change to the guard condition for managing initial Channel connect for the application.
 *  When this is invoked it means that this Channel is waiting to attempt to connect.
 * 
 *  @asparam event The PropertyChangeEvent dispatched by the RoyaleClient singleton.
 * @export
 * @param {mx.events.PropertyChangeEvent} event
 */
mx.messaging.Channel.prototype.royaleClientWaitHandler = function(event) {
  if (event.property == "waitForRoyaleClientId") {
    var /** @type {mx.messaging.RoyaleClient} */ royaleClient = org.apache.royale.utils.Language.as(event.source, mx.messaging.RoyaleClient);
    if (royaleClient.http_$$www_adobe_com$2006$flex$mx$internal__waitForRoyaleClientId == false) {
      royaleClient.removeEventListener(mx.events.PropertyChangeEvent.PROPERTY_CHANGE, org.apache.royale.utils.Language.closure(this.royaleClientWaitHandler, this, 'royaleClientWaitHandler'));
      royaleClient.http_$$www_adobe_com$2006$flex$mx$internal__waitForRoyaleClientId = true;
      this.mx_messaging_Channel__ownsWaitGuard = true;
      this.internalConnect();
    }
  }
};


/**
 *  Returns the appropriate MessageResponder for the Channel's
 *  <code>send()</code> method.
 *  Must be overridden.
 *
 *  @asparam agent The MessageAgent sending the message.
 * 
 *  @asparam message The Message to send.
 * 
 *  @asreturn The MessageResponder to handle the result or fault.
 * 
 *  @throws flash.errors.IllegalOperationError If the Channel subclass does not override
 *                                this method.
 * @export
 * @param {mx.messaging.MessageAgent} agent
 * @param {mx.messaging.messages.IMessage} message
 * @return {mx.messaging.MessageResponder}
 */
mx.messaging.Channel.prototype.getMessageResponder = function(agent, message) {
  throw new mx.errors.IllegalOperationError("Channel subclasses must override " + " getMessageResponder().");
};


/**
 *  Connects the Channel to its endpoint.
 *  Must be overridden.
 * @export
 */
mx.messaging.Channel.prototype.internalConnect = function() {
};


/**
 *  Disconnects the Channel from its endpoint. 
 *  Must be overridden.
 * 
 *  @asparam rejected True if the disconnect was due to a connection rejection or timeout
 *                  and reconnection should not be attempted automatically; otherwise false. 
 * @export
 * @param {boolean=} rejected
 */
mx.messaging.Channel.prototype.internalDisconnect = function(rejected) {
  rejected = typeof rejected !== 'undefined' ? rejected : false;
};


/**
 *  Sends the Message out over the Channel and routes the response to the
 *  responder.
 *  Must be overridden.
 * 
 *  @asparam messageResponder The MessageResponder to handle the response.
 * @export
 * @param {mx.messaging.MessageResponder} messageResponder
 */
mx.messaging.Channel.prototype.internalSend = function(messageResponder) {
};


/**
 * @asprivate
 * Utility method to examine the reported server messaging version and
 * thus determine which features are available.
 * @export
 * @param {number} version
 */
mx.messaging.Channel.prototype.handleServerMessagingVersion = function(version) {
  this.useSmallMessages = version >= this.messagingVersion;
};


/**
 *  @asprivate
 *  Utility method used to assign the RoyaleClient Id value to outbound messages.
 * 
 *  @asparam message The message to set the RoyaleClient Id on.
 * @export
 * @param {mx.messaging.messages.IMessage} message
 */
mx.messaging.Channel.prototype.setRoyaleClientIdOnMessage = function(message) {
  var /** @type {string} */ id = mx.messaging.RoyaleClient.getInstance().id;
  message.headers[mx.messaging.messages.AbstractMessage.FLEX_CLIENT_ID_HEADER] = (id != null) ? id : mx.messaging.RoyaleClient.NULL_ROYALECLIENT_ID;
};


/**
 *  @asprivate   
 *  This method calculates the endpoint value based on the current
 *  <code>uri</code>.
 * @private
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_calculateEndpoint = function() {
  if (this.uri == null) {
    var /** @type {string} */ message = this.mx_messaging_Channel_resourceManager.getString("messaging", "noURLSpecified");
    throw new mx.messaging.errors.InvalidChannelError(message);
  }
  var /** @type {string} */ uriCopy = this.uri;
  var /** @type {string} */ proto = mx.utils.URLUtil.getProtocol(uriCopy);
  if (proto.length == 0)
    uriCopy = mx.utils.URLUtil.getFullURL(mx.messaging.config.LoaderConfig["url"], uriCopy);
  if (mx.utils.URLUtil.hasTokens(uriCopy) && !mx.utils.URLUtil.hasUnresolvableTokens()) {
    this.mx_messaging_Channel__isEndpointCalculated = false;
    return;
  }
  uriCopy = mx.utils.URLUtil.replaceTokens(uriCopy);
  proto = mx.utils.URLUtil.getProtocol(uriCopy);
  if (proto.length > 0)
    this.mx_messaging_Channel__endpoint = mx.utils.URLUtil.replaceProtocol(uriCopy, this.protocol);
  else
    this.mx_messaging_Channel__endpoint = this.protocol + ":" + uriCopy;
  this.mx_messaging_Channel__isEndpointCalculated = true;
  if (mx.logging.Log.isInfo())
    this._log.info("'{0}' channel endpoint set to {1}", this.id, this.mx_messaging_Channel__endpoint);
};


/**
 *  @asprivate
 *  Initializes the request timeout for this message if the outbound message 
 *  defines a REQUEST_TIMEOUT_HEADER value. 
 *  If this header is not set and the default requestTimeout for the 
 *  channel is greater than 0, the channel default is used. 
 *  Otherwise, no request timeout is enforced on the client.
 * 
 *  @asparam messageResponder The MessageResponder to handle the response and monitor the outbound
 *                          request for a timeout.
 * @private
 * @param {mx.messaging.MessageResponder} messageResponder
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_initializeRequestTimeout = function(messageResponder) {
  var /** @type {mx.messaging.messages.IMessage} */ message = messageResponder.message;
  if (message.headers[mx.messaging.messages.AbstractMessage.REQUEST_TIMEOUT_HEADER] != null) {
    messageResponder.startRequestTimeout((message.headers[mx.messaging.messages.AbstractMessage.REQUEST_TIMEOUT_HEADER]) >> 0);
  } else if (this.requestTimeout > 0) {
    messageResponder.startRequestTimeout(this.requestTimeout);
  }
};


/**
 *  @asprivate
 *  Convenience method to test whether the Channel should attempt to
 *  failover.
 * 
 *  @asreturn <code>true</code> if the Channel should try to failover;
 *          otherwise <code>false</code>.
 * @private
 * @return {boolean}
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_shouldAttemptFailover = function() {
  return (this.mx_messaging_Channel__shouldBeConnected && (this.mx_messaging_Channel__previouslyConnected || (this.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration != -1) || ((this.mx_messaging_Channel__failoverURIs != null) && (this.mx_messaging_Channel__failoverURIs.length > 0))));
};


/**
 *  @asprivate
 *  This method attempts to fail the Channel over to the next available URI.
 * @private
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_failover = function() {
  if (this.mx_messaging_Channel__previouslyConnected) {
    this.mx_messaging_Channel__previouslyConnected = false;
    var /** @type {Object} */ acs = null;
    try {
      acs = org.apache.royale.utils.Language.as(org.apache.royale.reflection.getDefinitionByName("mx.messaging.AdvancedChannelSet"), org.apache.royale.utils.Language.synthType('Class'));
    } catch (ignore) {
    }
    var /** @type {number} */ duration = -1;
    if (acs != null) {
      var foreachiter1_target = this.channelSets;
      for (var foreachiter1 in foreachiter1_target) 
      {
      var channelSet = foreachiter1_target[foreachiter1];
      {
        if (org.apache.royale.utils.Language.is(channelSet, acs)) {
          var /** @type {number} */ d = (org.apache.royale.utils.Language.as(channelSet, acs)["reliableReconnectDuration"]) >> 0;
          if (d > duration)
            duration = d;
        }
      }}
      
    }
    if (duration != -1) {
      this.mx_messaging_Channel_setReconnecting(true);
      this.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration = duration;
      this.mx_messaging_Channel__reliableReconnectBeginTimestamp = Number(new Date().valueOf());
      new mx.rpc.AsyncDispatcher(org.apache.royale.utils.Language.closure(this.mx_messaging_Channel_reconnect, this, 'reconnect'), null, 1);
      return;
    }
  }
  if (this.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration != -1) {
    this.mx_messaging_Channel__reliableReconnectLastTimestamp = Number(new Date().valueOf());
    var /** @type {number} */ remaining = this.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration - (this.mx_messaging_Channel__reliableReconnectLastTimestamp - this.mx_messaging_Channel__reliableReconnectBeginTimestamp);
    if (remaining > 0) {
      var /** @type {number} */ delay = 1000;
      delay = delay << ++this.mx_messaging_Channel__reliableReconnectAttempts;
      if (delay < remaining) {
        new mx.rpc.AsyncDispatcher(org.apache.royale.utils.Language.closure(this.mx_messaging_Channel_reconnect, this, 'reconnect'), null, delay);
        return;
      }
    }
    this.mx_messaging_Channel_reliableReconnectCleanup();
  }
  ++this.mx_messaging_Channel__failoverIndex;
  if ((this.mx_messaging_Channel__failoverIndex + 1) <= this.failoverURIs.length) {
    this.mx_messaging_Channel_setReconnecting(true);
    this.uri = org.apache.royale.utils.Language.string(this.failoverURIs[this.mx_messaging_Channel__failoverIndex]);
    if (mx.logging.Log.isInfo()) {
      this._log.info("'{0}' channel attempting to connect to {1}.", this.id, this.endpoint);
    }
    new mx.rpc.AsyncDispatcher(org.apache.royale.utils.Language.closure(this.mx_messaging_Channel_reconnect, this, 'reconnect'), null, 1);
  } else {
    if (mx.logging.Log.isInfo()) {
      this._log.info("'{0}' channel has exhausted failover options and has reset to its primary endpoint.", this.id);
    }
    this.mx_messaging_Channel_resetToPrimaryURI();
  }
};


/**
 *  @asprivate
 *  Cleanup following a connect or failover attempt.
 * @private
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_connectCleanup = function() {
  if (this.mx_messaging_Channel__ownsWaitGuard) {
    this.mx_messaging_Channel__ownsWaitGuard = false;
    mx.messaging.RoyaleClient.getInstance().http_$$www_adobe_com$2006$flex$mx$internal__waitForRoyaleClientId = false;
  }
  this._connecting = false;
  this.mx_messaging_Channel_setReconnecting(false);
  this.mx_messaging_Channel_reliableReconnectCleanup();
};


/**
 *  @asprivate
 *  This method is invoked by a timer from failover() and it works around a 
 *  reconnect issue with NetConnection based channels by invoking 
 *  internalConnect() after a slight delay.
 * @private
 * @param {org.apache.royale.events.Event=} event
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_reconnect = function(event) {
  event = typeof event !== 'undefined' ? event : null;
  this.internalConnect();
};


/**
 *  @asprivate
 *  Cleanup following a reliable reconnect attempt.
 * @private
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_reliableReconnectCleanup = function() {
  this.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration = -1;
  this.mx_messaging_Channel__reliableReconnectBeginTimestamp = 0;
  this.mx_messaging_Channel__reliableReconnectLastTimestamp = 0;
  this.mx_messaging_Channel__reliableReconnectAttempts = 0;
};


/**
 *  @asprivate
 *  This method resets the channel back to its primary URI after
 *  exhausting all failover URIs.
 * @private
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_resetToPrimaryURI = function() {
  this._connecting = false;
  this.mx_messaging_Channel_setReconnecting(false);
  this.uri = this.mx_messaging_Channel__primaryURI;
  this.mx_messaging_Channel__failoverIndex = -1;
};


/**
 *  @asprivate
 *  Shuffles the array.
 * @private
 * @param {Array} elements
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_shuffle = function(elements) {
  var /** @type {number} */ length = (elements.length) >> 0;
  for (var /** @type {number} */ i = 0; i < length; i++) {
    var /** @type {number} */ index = (Math.floor(Math.random() * length)) >> 0;
    if (index != i) {
      var /** @type {Object} */ temp = elements[i];
      elements[i] = elements[index];
      elements[index] = temp;
    }
  }
};


/**
 *  @asprivate
 *  Shuts down and nulls out the connect timer.
 * @private
 */
mx.messaging.Channel.prototype.mx_messaging_Channel_shutdownConnectTimer = function() {
  if (this.mx_messaging_Channel__connectTimer != null) {
    this.mx_messaging_Channel__connectTimer.stop();
    this.mx_messaging_Channel__connectTimer.removeEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.connectTimeoutHandler, this, 'connectTimeoutHandler'));
    this.mx_messaging_Channel__connectTimer = null;
  }
};


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.Channel.SMALL_MESSAGES_FEATURE = "small_messages";


/**
 * @private
 * @const
 * @type {mx.collections.ArrayCollection}
 */
mx.messaging.Channel.dep = null;


mx.messaging.Channel.prototype.get__channelSets = function() {
  return this.mx_messaging_Channel__channelSets;
};


mx.messaging.Channel.prototype.get__connected = function() {
  return this.mx_messaging_Channel__connected;
};


mx.messaging.Channel.prototype.get__connectTimeout = function() {
  return this.mx_messaging_Channel__connectTimeout;
};


mx.messaging.Channel.prototype.set__connectTimeout = function(value) {
  this.mx_messaging_Channel__connectTimeout = value;
};


mx.messaging.Channel.prototype.get__endpoint = function() {
  if (!this.mx_messaging_Channel__isEndpointCalculated)
    this.mx_messaging_Channel_calculateEndpoint();
  return this.mx_messaging_Channel__endpoint;
};


mx.messaging.Channel.prototype.get__recordMessageTimes = function() {
  return this._recordMessageTimes;
};


mx.messaging.Channel.prototype.get__recordMessageSizes = function() {
  return this._recordMessageSizes;
};


mx.messaging.Channel.prototype.get__reconnecting = function() {
  return this.mx_messaging_Channel__reconnecting;
};


mx.messaging.Channel.prototype.get__failoverURIs = function() {
  return (this.mx_messaging_Channel__failoverURIs != null) ? this.mx_messaging_Channel__failoverURIs : [];
};


mx.messaging.Channel.prototype.set__failoverURIs = function(value) {
  if (value != null) {
    this.mx_messaging_Channel__failoverURIs = value;
    this.mx_messaging_Channel__failoverIndex = -1;
  }
};


mx.messaging.Channel.prototype.get__id = function() {
  return this.mx_messaging_Channel__id;
};


mx.messaging.Channel.prototype.set__id = function(value) {
  if (this.mx_messaging_Channel__id != value)
    this.mx_messaging_Channel__id = value;
};


mx.messaging.Channel.prototype.get__authenticated = function() {
  return this.mx_messaging_Channel__authenticated;
};


mx.messaging.Channel.prototype.get__protocol = function() {
  throw new mx.errors.IllegalOperationError("Channel subclasses must override " + "the get function for 'protocol' to return the proper protocol " + "string.");
};


mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__realtime = function() {
  return false;
};


mx.messaging.Channel.prototype.get__requestTimeout = function() {
  return this.mx_messaging_Channel__requestTimeout;
};


mx.messaging.Channel.prototype.set__requestTimeout = function(value) {
  this.mx_messaging_Channel__requestTimeout = value;
};


mx.messaging.Channel.prototype.get__shouldBeConnected = function() {
  return this.mx_messaging_Channel__shouldBeConnected;
};


mx.messaging.Channel.prototype.get__uri = function() {
  return this.mx_messaging_Channel__uri;
};


mx.messaging.Channel.prototype.set__uri = function(value) {
  if (value != null) {
    this.mx_messaging_Channel__uri = value;
    this.mx_messaging_Channel_calculateEndpoint();
  }
};


mx.messaging.Channel.prototype.get__url = function() {
  return this.uri;
};


mx.messaging.Channel.prototype.set__url = function(value) {
  this.uri = value;
};


mx.messaging.Channel.prototype.get__useSmallMessages = function() {
  return this.mx_messaging_Channel__smallMessagesSupported && this.enableSmallMessages;
};


mx.messaging.Channel.prototype.set__useSmallMessages = function(value) {
  this.mx_messaging_Channel__smallMessagesSupported = value;
};


mx.messaging.Channel.prototype.get__mpiEnabled = function() {
  return this._recordMessageSizes || this._recordMessageTimes;
};


Object.defineProperties(mx.messaging.Channel.prototype, /** @lends {mx.messaging.Channel.prototype} */ {
/**
  * @export
  * @type {Array} */
channelSets: {
get: mx.messaging.Channel.prototype.get__channelSets},
/**
  * @export
  * @type {boolean} */
connected: {
get: mx.messaging.Channel.prototype.get__connected},
/**
  * @export
  * @type {number} */
connectTimeout: {
get: mx.messaging.Channel.prototype.get__connectTimeout,
set: mx.messaging.Channel.prototype.set__connectTimeout},
/**
  * @export
  * @type {string} */
endpoint: {
get: mx.messaging.Channel.prototype.get__endpoint},
/**
  * @export
  * @type {boolean} */
recordMessageTimes: {
get: mx.messaging.Channel.prototype.get__recordMessageTimes},
/**
  * @export
  * @type {boolean} */
recordMessageSizes: {
get: mx.messaging.Channel.prototype.get__recordMessageSizes},
/**
  * @export
  * @type {boolean} */
reconnecting: {
get: mx.messaging.Channel.prototype.get__reconnecting},
/**
  * @export
  * @type {Array} */
failoverURIs: {
get: mx.messaging.Channel.prototype.get__failoverURIs,
set: mx.messaging.Channel.prototype.set__failoverURIs},
/**
  * @export
  * @type {string} */
id: {
get: mx.messaging.Channel.prototype.get__id,
set: mx.messaging.Channel.prototype.set__id},
/**
  * @export
  * @type {boolean} */
authenticated: {
get: mx.messaging.Channel.prototype.get__authenticated},
/**
  * @export
  * @type {string} */
protocol: {
get: mx.messaging.Channel.prototype.get__protocol},
/**
  * @export
  * @type {boolean} */
http_$$www_adobe_com$2006$flex$mx$internal__realtime: {
get: mx.messaging.Channel.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__realtime},
/**
  * @export
  * @type {number} */
requestTimeout: {
get: mx.messaging.Channel.prototype.get__requestTimeout,
set: mx.messaging.Channel.prototype.set__requestTimeout},
/**
  * @type {boolean} */
shouldBeConnected: {
get: mx.messaging.Channel.prototype.get__shouldBeConnected},
/**
  * @export
  * @type {string} */
uri: {
get: mx.messaging.Channel.prototype.get__uri,
set: mx.messaging.Channel.prototype.set__uri},
/**
  * @export
  * @type {string} */
url: {
get: mx.messaging.Channel.prototype.get__url,
set: mx.messaging.Channel.prototype.set__url},
/**
  * @export
  * @type {boolean} */
useSmallMessages: {
get: mx.messaging.Channel.prototype.get__useSmallMessages,
set: mx.messaging.Channel.prototype.set__useSmallMessages},
/**
  * @export
  * @type {boolean} */
mpiEnabled: {
get: mx.messaging.Channel.prototype.get__mpiEnabled}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.Channel.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Channel', qName: 'mx.messaging.Channel', kind: 'class' }], interfaces: [mx.core.IMXMLObject] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.Channel.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'http://www.adobe.com/2006/flex/mx/internal::authenticating': { type: 'Boolean', get_set: function (/** mx.messaging.Channel */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__authenticating = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__authenticating;}},
        'enableSmallMessages': { type: 'Boolean', get_set: function (/** mx.messaging.Channel */ inst, /** * */ v) {return v !== undefined ? inst.enableSmallMessages = v : inst.enableSmallMessages;}},
        'http://www.adobe.com/2006/flex/mx/internal::reliableReconnectDuration': { type: 'int', get_set: function (/** mx.messaging.Channel */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__reliableReconnectDuration;}}
      };
    },
    accessors: function () {
      return {
        'channelSets': { type: 'Array', access: 'readonly', declaredBy: 'mx.messaging.Channel'},
        'connected': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'connectTimeout': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'endpoint': { type: 'String', access: 'readonly', declaredBy: 'mx.messaging.Channel'},
        'recordMessageTimes': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel'},
        'recordMessageSizes': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel'},
        'reconnecting': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'failoverURIs': { type: 'Array', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'id': { type: 'String', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'authenticated': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'protocol': { type: 'String', access: 'readonly', declaredBy: 'mx.messaging.Channel'},
        'http://www.adobe.com/2006/flex/mx/internal::realtime': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel'},
        'requestTimeout': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'uri': { type: 'String', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'url': { type: 'String', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'useSmallMessages': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.messaging.Channel'},
        'mpiEnabled': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.Channel'}
      };
    },
    methods: function () {
      return {
        'Channel': { type: '', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'String', true ,'String', true ]; }},
        'initialized': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'Object', false ,'String', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::setAuthenticated': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'Boolean', false ]; }},
        'applySettings': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'XML', false ]; }},
        'connect': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'mx.messaging.ChannelSet', false ]; }},
        'disconnect': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'mx.messaging.ChannelSet', false ]; }},
        'logout': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'mx.messaging.MessageAgent', false ]; }},
        'send': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'mx.messaging.MessageAgent', false ,'mx.messaging.messages.IMessage', false ]; }},
        'setCredentials': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'String', false ,'mx.messaging.MessageAgent', true ,'String', true ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::internalSetCredentials': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'String', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::sendInternalMessage': { type: 'void', declaredBy: 'mx.messaging.Channel', parameters: function () { return [ 'mx.messaging.MessageResponder', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.Channel.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 * @constructor
 * @extends {mx.messaging.MessageResponder}
 * @param {mx.messaging.MessageAgent} agent
 * @param {mx.messaging.messages.IMessage} message
 * @param {mx.messaging.Channel} channel
 * @param {mx.logging.ILogger} log
 */
mx.messaging.Channel.AuthenticationMessageResponder = function(agent, message, channel, log) {
  mx.messaging.Channel.AuthenticationMessageResponder.base(this, 'constructor', agent, message, channel);
  this.AuthenticationMessageResponder__log = log;
};
goog.inherits(mx.messaging.Channel.AuthenticationMessageResponder, mx.messaging.MessageResponder);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.Channel.AuthenticationMessageResponder', mx.messaging.Channel.AuthenticationMessageResponder);


/**
 * @private
 * @type {mx.logging.ILogger}
 */
mx.messaging.Channel.AuthenticationMessageResponder.prototype.AuthenticationMessageResponder__log;


/**
 *  Handles an authentication result.
 * 
 *  @asparam msg The result Message.
 * @export
 * @override
 */
mx.messaging.Channel.AuthenticationMessageResponder.prototype.resultHandler = function(msg) {
  var /** @type {mx.messaging.messages.CommandMessage} */ cmd = org.apache.royale.utils.Language.as(this.message, mx.messaging.messages.CommandMessage);
  this.channel.http_$$www_adobe_com$2006$flex$mx$internal__authenticating = false;
  if (cmd.operation == mx.messaging.messages.CommandMessage.LOGIN_OPERATION) {
    if (mx.logging.Log.isDebug())
      this.AuthenticationMessageResponder__log.debug("Login successful");
    this.channel[new QName(mx.core.mx_internal, 'setAuthenticated').objectAccessFormat()](true);
  } else {
    if (mx.logging.Log.isDebug())
      this.AuthenticationMessageResponder__log.debug("Logout successful");
    this.channel[new QName(mx.core.mx_internal, 'setAuthenticated').objectAccessFormat()](false);
  }
};


/**
 *  Handles an authentication failure.
 * 
 *  @asparam msg The failure Message.
 * @export
 * @override
 */
mx.messaging.Channel.AuthenticationMessageResponder.prototype.statusHandler = function(msg) {
  var /** @type {mx.messaging.messages.CommandMessage} */ cmd = org.apache.royale.utils.Language.as(this.message, mx.messaging.messages.CommandMessage, true);
  if (mx.logging.Log.isDebug()) {
    this.AuthenticationMessageResponder__log.debug("{1} failure: {0}", msg.toString(), cmd.operation == mx.messaging.messages.CommandMessage.LOGIN_OPERATION ? "Login" : "Logout");
  }
  this.channel.http_$$www_adobe_com$2006$flex$mx$internal__authenticating = false;
  this.channel[new QName(mx.core.mx_internal, 'setAuthenticated').objectAccessFormat()](false);
  if (this.agent != null && this.agent.hasPendingRequestForMessage(this.message)) {
    this.agent.fault(org.apache.royale.utils.Language.as(msg, mx.messaging.messages.ErrorMessage, true), this.message);
  } else {
    var /** @type {mx.messaging.messages.ErrorMessage} */ errMsg = org.apache.royale.utils.Language.as(msg, mx.messaging.messages.ErrorMessage, true);
    var /** @type {mx.messaging.events.ChannelFaultEvent} */ channelFault = mx.messaging.events.ChannelFaultEvent.createEvent(this.channel, false, "Channel.Authentication.Error", "warn", errMsg.faultString);
    channelFault.rootCause = errMsg;
    this.channel.dispatchEvent(channelFault);
  }
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.Channel.AuthenticationMessageResponder.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'AuthenticationMessageResponder', qName: 'mx.messaging.Channel.AuthenticationMessageResponder', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.Channel.AuthenticationMessageResponder.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'AuthenticationMessageResponder': { type: '', declaredBy: 'mx.messaging.Channel.AuthenticationMessageResponder', parameters: function () { return [ 'mx.messaging.MessageAgent', false ,'mx.messaging.messages.IMessage', false ,'mx.messaging.Channel', false ,'mx.logging.ILogger', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.Channel.AuthenticationMessageResponder.prototype.ROYALE_COMPILE_FLAGS = 26;
