/**
 * Generated by Apache Royale Compiler from mx/messaging/AbstractProducer.as
 * mx.messaging.AbstractProducer
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.messaging.AbstractProducer');
/* Royale Dependency List: mx.core.mx_internal,mx.events.PropertyChangeEvent,mx.logging.Log,mx.messaging.errors.ArgumentError,mx.messaging.events.ChannelEvent,mx.messaging.events.ChannelFaultEvent,mx.messaging.messages.AcknowledgeMessage,mx.messaging.messages.CommandMessage,mx.messaging.messages.ErrorMessage,mx.messaging.messages.IMessage,mx.resources.IResourceManager,mx.resources.ResourceManager,org.apache.royale.events.Event,org.apache.royale.utils.Timer,org.apache.royale.utils.Language,XML*/

goog.require('mx.messaging.MessageAgent');



/**
 * @asprivate
 * @constructor
 * @extends {mx.messaging.MessageAgent}
 */
mx.messaging.AbstractProducer = function() {
  
  this.mx_messaging_AbstractProducer_resourceManager = mx.resources.ResourceManager.getInstance();
  mx.messaging.AbstractProducer.base(this, 'constructor');
};
goog.inherits(mx.messaging.AbstractProducer, mx.messaging.MessageAgent);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.AbstractProducer', mx.messaging.AbstractProducer);


/**
 * @private
 * @type {mx.messaging.messages.CommandMessage}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__connectMsg;


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__currentAttempt = 0;


/**
 * @private
 * @type {org.apache.royale.utils.Timer}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__reconnectTimer;


/**
 * @export
 * @type {boolean}
 */
mx.messaging.AbstractProducer.prototype._shouldBeConnected;


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer_resourceManager;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__autoConnect = true;


/**
 * @private
 * @type {Object}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__defaultHeaders;


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__priority = -1;


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__reconnectAttempts = 0;


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer__reconnectInterval = 0;


/**
 *  @asprivate
 *  Custom processing for message acknowledgments. 
 *  Specifically, re/connect acknowledgements.
 * 
 *  @asparam ackMsg The AcknowledgeMessage.
 * 
 *  @asparam msg The original message.
 * @export
 * @override
 */
mx.messaging.AbstractProducer.prototype.acknowledge = function(ackMsg, msg) {
  if (this._disconnectBarrier)
    return;
  mx.messaging.AbstractProducer.superClass_.acknowledge.apply(this, [ ackMsg, msg] );
  if (org.apache.royale.utils.Language.is(msg, mx.messaging.messages.CommandMessage) && org.apache.royale.utils.Language.as(msg, mx.messaging.messages.CommandMessage, true).operation == mx.messaging.messages.CommandMessage.TRIGGER_CONNECT_OPERATION)
    this.stopReconnectTimer();
};


/**
 *  @asprivate
 *  The Producer suppresses ErrorMessage processing if the fault is for a connect
 *  attempt that is being retried.
 * 
 *  @asparam errMsg The ErrorMessage describing the fault.
 * 
 *  @asparam msg The original message.
 * @export
 * @override
 */
mx.messaging.AbstractProducer.prototype.fault = function(errMsg, msg) {
  this.http_$$www_adobe_com$2006$flex$mx$internal__internalFault(errMsg, msg);
};


/**
 *  @asprivate
 *  Custom processing to start up a reconnect timer if our channel is
 *  disconnected when we should be connected.
 * 
 *  @asparam event The ChannelEvent.
 * @export
 * @override
 */
mx.messaging.AbstractProducer.prototype.channelDisconnectHandler = function(event) {
  mx.messaging.AbstractProducer.superClass_.channelDisconnectHandler.apply(this, [ event] );
  if (this._shouldBeConnected && !event.rejected)
    this.startReconnectTimer();
};


/**
 *  @asprivate
 *  Custom processing to start up a reconnect timer if our channel faults
 *  when we should be connected.
 * 
 *  @asparam event The ChannelFaultEvent.
 * @export
 * @override
 */
mx.messaging.AbstractProducer.prototype.channelFaultHandler = function(event) {
  mx.messaging.AbstractProducer.superClass_.channelFaultHandler.apply(this, [ event] );
  if (this._shouldBeConnected && !event.rejected && !event.channel.connected)
    this.startReconnectTimer();
};


/**
 *  Disconnects the Producer from its remote destination.
 *  This method does not wait for outstanding network operations to complete.
 *  After invoking <code>disconnect()</code>, the Producer will report that it is not
 *  connected and it will not receive any outstanding message acknowledgements or faults.
 *  Disconnecting stops automatic reconnect attempts if they are running.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @override
 */
mx.messaging.AbstractProducer.prototype.disconnect = function() {
  this._shouldBeConnected = false;
  this.stopReconnectTimer();
  mx.messaging.AbstractProducer.superClass_.disconnect.apply(this);
};


/**
 *  Connects the Producer to its target destination.
 *  When a connection is established the <code>connected</code> property will
 *  change to <code>true</code> and this property is bindable and generates
 *  <code>PropertyChangeEvent</code>s.
 *  The internal TRIGGER_CONNECT_OPERATION CommandMessage that is sent will result
 *  in an acknowledge or fault event depending upon whether the underlying channel
 *  establishes its connection.
 * 
 *  @throws mx.messaging.errors.InvalidDestinationError  If no destination is set.
 * 
 *  @example
 *  <pre>
 *     var producer:Producer = new Producer();
 *     producer.destination = "TestTopic";
 *     producer.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, handleConnect);
 *     producer.connect();
 *  </pre>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 */
mx.messaging.AbstractProducer.prototype.connect = function() {
  if (!this.connected) {
    this._shouldBeConnected = true;
    if (this.mx_messaging_AbstractProducer__connectMsg == null)
      this.mx_messaging_AbstractProducer__connectMsg = this.mx_messaging_AbstractProducer_buildConnectMessage();
    this.internalSend(this.mx_messaging_AbstractProducer__connectMsg, false);
  }
};


/**
 *  Sends the specified message to its destination.
 *  If the producer is being used for publish/subscribe messaging, only messages of type AsyncMessage
 *  should be sent unless a custom message type is being used and the 
 *  message destination on the server has been configured to process the
 *  custom message type.
 *
 *  @asparam message The Message to send.
 * 
 *  @throws mx.messaging.errors.InvalidDestinationError  If no destination is set.
 * 
 *  @example
 *  <pre>
 *     var producer:Producer = new Producer();
 *     producer.destination = "TestTopic";
 *     var msg:AsyncMessage = new AsyncMessage();
 *     msg.body = "test message";
 *     producer.send(msg);
 *  </pre>
 *
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {mx.messaging.messages.IMessage} message
 */
mx.messaging.AbstractProducer.prototype.send = function(message) {
  if (!this.connected && this.autoConnect)
    this._shouldBeConnected = true;
  if (this.defaultHeaders != null) {
    for (var /** @type {string} */ header in this.defaultHeaders) {
      if (!message.headers.hasOwnProperty(header))
        message.headers[header] = this.defaultHeaders[header];
    }
  }
  if (!this.connected && !this.autoConnect) {
    this._shouldBeConnected = false;
    var /** @type {mx.messaging.messages.ErrorMessage} */ errMsg2 = new mx.messaging.messages.ErrorMessage();
    errMsg2.faultCode = "Client.Error.MessageSend";
    errMsg2.faultString = this.mx_messaging_AbstractProducer_resourceManager.getString("messaging", "producerSendError");
    errMsg2.faultDetail = this.mx_messaging_AbstractProducer_resourceManager.getString("messaging", "producerSendErrorDetails");
    errMsg2.correlationId = message.messageId;
    this.http_$$www_adobe_com$2006$flex$mx$internal__internalFault(errMsg2, message, false, true);
  } else {
    if (mx.logging.Log.isInfo())
      this._log.info("'{0}' {1} sending message '{2}'", this.id, this._agentType, message.messageId);
    this.internalSend(message);
  }
};


/**
 *  @asprivate
 *  The Producer suppresses ErrorMessage processing if the fault is for a connect
 *  attempt that is being retried.
 * 
 *  @asparam errMsg The ErrorMessage describing the fault.
 * 
 *  @asparam msg The original message.
 * 
 *  @asparam routeToStore currently not used.  Previously was a flag used to
 *  indicate if the faulted message shoudl be stored offline to retry.
 * 
 *  @asparam ignoreDisconnectBarrier If true the message is faulted regardless 
 *  of whether disconnect() has been invoked. Generally a disconnect() will 
 *  suppress pending acks and faults.
 * @export
 * @param {mx.messaging.messages.ErrorMessage} errMsg
 * @param {mx.messaging.messages.IMessage} msg
 * @param {boolean=} routeToStore
 * @param {boolean=} ignoreDisconnectBarrier
 */
mx.messaging.AbstractProducer.prototype.http_$$www_adobe_com$2006$flex$mx$internal__internalFault = function(errMsg, msg, routeToStore, ignoreDisconnectBarrier) {
  routeToStore = typeof routeToStore !== 'undefined' ? routeToStore : true;
  ignoreDisconnectBarrier = typeof ignoreDisconnectBarrier !== 'undefined' ? ignoreDisconnectBarrier : false;
  if (this._disconnectBarrier && !ignoreDisconnectBarrier)
    return;
  if (org.apache.royale.utils.Language.is(msg, mx.messaging.messages.CommandMessage) && org.apache.royale.utils.Language.as(msg, mx.messaging.messages.CommandMessage, true).operation == mx.messaging.messages.CommandMessage.TRIGGER_CONNECT_OPERATION) {
    if (this.mx_messaging_AbstractProducer__reconnectTimer == null) {
      if ((this.mx_messaging_AbstractProducer__connectMsg != null) && (errMsg.correlationId == this.mx_messaging_AbstractProducer__connectMsg.messageId)) {
        this._shouldBeConnected = false;
        var /** @type {mx.messaging.messages.ErrorMessage} */ errMsg2 = this.mx_messaging_AbstractProducer_buildConnectErrorMessage();
        errMsg2.rootCause = errMsg.rootCause;
        mx.messaging.AbstractProducer.superClass_.fault.apply(this, [ errMsg2, msg] );
      } else {
        mx.messaging.AbstractProducer.superClass_.fault.apply(this, [ errMsg, msg] );
      }
    }
  } else {
    mx.messaging.AbstractProducer.superClass_.fault.apply(this, [ errMsg, msg] );
  }
};


/**
 *  @asprivate
 *  Attempt to reconnect.  This can be called directly or
 *  from a Timer's event handler.
 * 
 *  @asparam event The timer event for reconnect attempts.
 * @export
 * @param {org.apache.royale.events.Event} event
 */
mx.messaging.AbstractProducer.prototype.reconnect = function(event) {
  if ((this.mx_messaging_AbstractProducer__reconnectAttempts != -1) && (this.mx_messaging_AbstractProducer__currentAttempt >= this.mx_messaging_AbstractProducer__reconnectAttempts)) {
    this.stopReconnectTimer();
    this._shouldBeConnected = false;
    this.fault(this.mx_messaging_AbstractProducer_buildConnectErrorMessage(), this.mx_messaging_AbstractProducer__connectMsg);
    return;
  }
  if (mx.logging.Log.isDebug())
    this._log.debug("'{0}' {1} trying to reconnect.", this.id, this._agentType);
  this.mx_messaging_AbstractProducer__reconnectTimer.delay = this.mx_messaging_AbstractProducer__reconnectInterval;
  this.mx_messaging_AbstractProducer__currentAttempt++;
  if (this.mx_messaging_AbstractProducer__connectMsg == null)
    this.mx_messaging_AbstractProducer__connectMsg = this.mx_messaging_AbstractProducer_buildConnectMessage();
  this.internalSend(this.mx_messaging_AbstractProducer__connectMsg, false);
};


/**
 *  @asprivate
 *  This method will start a timer which attempts to reconnect 
 *  periodically. 
 * @export
 */
mx.messaging.AbstractProducer.prototype.startReconnectTimer = function() {
  if (this._shouldBeConnected && (this.mx_messaging_AbstractProducer__reconnectTimer == null)) {
    if ((this.mx_messaging_AbstractProducer__reconnectAttempts != 0) && (this.mx_messaging_AbstractProducer__reconnectInterval > 0)) {
      if (mx.logging.Log.isDebug())
        this._log.debug("'{0}' {1} starting reconnect timer.", this.id, this._agentType);
      this.mx_messaging_AbstractProducer__reconnectTimer = new org.apache.royale.utils.Timer(1);
      this.mx_messaging_AbstractProducer__reconnectTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.reconnect, this, 'reconnect'));
      this.mx_messaging_AbstractProducer__reconnectTimer.start();
      this.mx_messaging_AbstractProducer__currentAttempt = 0;
    }
  }
};


/**
 * @asprivate 
 * Stops a reconnect timer if one is running.
 * @export
 */
mx.messaging.AbstractProducer.prototype.stopReconnectTimer = function() {
  if (this.mx_messaging_AbstractProducer__reconnectTimer != null) {
    if (mx.logging.Log.isDebug())
      this._log.debug("'{0}' {1} stopping reconnect timer.", this.id, this._agentType);
    this.mx_messaging_AbstractProducer__reconnectTimer.removeEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.reconnect, this, 'reconnect'));
    this.mx_messaging_AbstractProducer__reconnectTimer.reset();
    this.mx_messaging_AbstractProducer__reconnectTimer = null;
  }
};


/**
 *  @asprivate
 *  Builds an ErrorMessage for a failed connect attempt.
 * 
 *  @asreturn The ErrorMessage.
 * @private
 * @return {mx.messaging.messages.ErrorMessage}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer_buildConnectErrorMessage = function() {
  var /** @type {mx.messaging.messages.ErrorMessage} */ errMsg = new mx.messaging.messages.ErrorMessage();
  errMsg.faultCode = "Client.Error.Connect";
  errMsg.faultString = this.mx_messaging_AbstractProducer_resourceManager.getString("messaging", "producerConnectError");
  errMsg.faultDetail = this.mx_messaging_AbstractProducer_resourceManager.getString("messaging", "failedToConnect");
  errMsg.correlationId = this.mx_messaging_AbstractProducer__connectMsg.messageId;
  return errMsg;
};


/**
 *  @asprivate
 *  Builds a 'connect' message to use for a connect attempt.
 *  
 *  @asreturn The 'connect' CommandMessage.
 * @private
 * @return {mx.messaging.messages.CommandMessage}
 */
mx.messaging.AbstractProducer.prototype.mx_messaging_AbstractProducer_buildConnectMessage = function() {
  var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
  msg.operation = mx.messaging.messages.CommandMessage.TRIGGER_CONNECT_OPERATION;
  msg.clientId = this.clientId;
  msg.destination = this.destination;
  return msg;
};


mx.messaging.AbstractProducer.prototype.get__autoConnect = function() {
  return this.mx_messaging_AbstractProducer__autoConnect;
};


mx.messaging.AbstractProducer.prototype.set__autoConnect = function(value) {
  if (this.mx_messaging_AbstractProducer__autoConnect != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "autoConnect", this.mx_messaging_AbstractProducer__autoConnect, value);
    this.mx_messaging_AbstractProducer__autoConnect = value;
    this.dispatchEvent(event);
  }
};


mx.messaging.AbstractProducer.prototype.get__defaultHeaders = function() {
  return this.mx_messaging_AbstractProducer__defaultHeaders;
};


mx.messaging.AbstractProducer.prototype.set__defaultHeaders = function(value) {
  if (this.mx_messaging_AbstractProducer__defaultHeaders != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "defaultHeaders", this.mx_messaging_AbstractProducer__defaultHeaders, value);
    this.mx_messaging_AbstractProducer__defaultHeaders = value;
    this.dispatchEvent(event);
  }
};


mx.messaging.AbstractProducer.prototype.get__priority = function() {
  return this.mx_messaging_AbstractProducer__priority;
};


mx.messaging.AbstractProducer.prototype.set__priority = function(value) {
  if (this.mx_messaging_AbstractProducer__priority != value) {
    value = (value < 0 ? 0 : value > 9 ? 9 : value) >> 0;
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "priority", this.mx_messaging_AbstractProducer__priority, value);
    this.mx_messaging_AbstractProducer__priority = value;
    this.dispatchEvent(event);
  }
};


mx.messaging.AbstractProducer.prototype.get__reconnectAttempts = function() {
  return this.mx_messaging_AbstractProducer__reconnectAttempts;
};


mx.messaging.AbstractProducer.prototype.set__reconnectAttempts = function(value) {
  if (this.mx_messaging_AbstractProducer__reconnectAttempts != value) {
    if (value == 0)
      this.stopReconnectTimer();
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "reconnectAttempts", this.mx_messaging_AbstractProducer__reconnectAttempts, value);
    this.mx_messaging_AbstractProducer__reconnectAttempts = value;
    this.dispatchEvent(event);
  }
};


mx.messaging.AbstractProducer.prototype.get__reconnectInterval = function() {
  return this.mx_messaging_AbstractProducer__reconnectInterval;
};


mx.messaging.AbstractProducer.prototype.set__reconnectInterval = function(value) {
  if (this.mx_messaging_AbstractProducer__reconnectInterval != value) {
    if (value < 0) {
      var /** @type {string} */ message = this.mx_messaging_AbstractProducer_resourceManager.getString("messaging", "reconnectIntervalNegative");
      throw new mx.messaging.errors.ArgumentError(message);
    } else if (value == 0) {
      this.stopReconnectTimer();
    } else if (this.mx_messaging_AbstractProducer__reconnectTimer != null) {
      this.mx_messaging_AbstractProducer__reconnectTimer.delay = value;
    }
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "reconnectInterval", this.mx_messaging_AbstractProducer__reconnectInterval, value);
    this.mx_messaging_AbstractProducer__reconnectInterval = value;
    this.dispatchEvent(event);
  }
};


Object.defineProperties(mx.messaging.AbstractProducer.prototype, /** @lends {mx.messaging.AbstractProducer.prototype} */ {
/**
  * @export
  * @type {boolean} */
autoConnect: {
get: mx.messaging.AbstractProducer.prototype.get__autoConnect,
set: mx.messaging.AbstractProducer.prototype.set__autoConnect},
/**
  * @export
  * @type {Object} */
defaultHeaders: {
get: mx.messaging.AbstractProducer.prototype.get__defaultHeaders,
set: mx.messaging.AbstractProducer.prototype.set__defaultHeaders},
/**
  * @export
  * @type {number} */
priority: {
get: mx.messaging.AbstractProducer.prototype.get__priority,
set: mx.messaging.AbstractProducer.prototype.set__priority},
/**
  * @export
  * @type {number} */
reconnectAttempts: {
get: mx.messaging.AbstractProducer.prototype.get__reconnectAttempts,
set: mx.messaging.AbstractProducer.prototype.set__reconnectAttempts},
/**
  * @export
  * @type {number} */
reconnectInterval: {
get: mx.messaging.AbstractProducer.prototype.get__reconnectInterval,
set: mx.messaging.AbstractProducer.prototype.set__reconnectInterval}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.AbstractProducer.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'AbstractProducer', qName: 'mx.messaging.AbstractProducer', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.AbstractProducer.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'autoConnect': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.messaging.AbstractProducer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'defaultHeaders': { type: 'Object', access: 'readwrite', declaredBy: 'mx.messaging.AbstractProducer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'priority': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.AbstractProducer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'reconnectAttempts': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.AbstractProducer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'reconnectInterval': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.AbstractProducer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }}
      };
    },
    methods: function () {
      return {
        'AbstractProducer': { type: '', declaredBy: 'mx.messaging.AbstractProducer'},
        'acknowledge': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer', parameters: function () { return [ 'mx.messaging.messages.AcknowledgeMessage', false ,'mx.messaging.messages.IMessage', false ]; }},
        'fault': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer', parameters: function () { return [ 'mx.messaging.messages.ErrorMessage', false ,'mx.messaging.messages.IMessage', false ]; }},
        'channelDisconnectHandler': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer', parameters: function () { return [ 'mx.messaging.events.ChannelEvent', false ]; }},
        'channelFaultHandler': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer', parameters: function () { return [ 'mx.messaging.events.ChannelFaultEvent', false ]; }},
        'disconnect': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer'},
        'connect': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer'},
        'send': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer', parameters: function () { return [ 'mx.messaging.messages.IMessage', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::internalFault': { type: 'void', declaredBy: 'mx.messaging.AbstractProducer', parameters: function () { return [ 'mx.messaging.messages.ErrorMessage', false ,'mx.messaging.messages.IMessage', false ,'Boolean', true ,'Boolean', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.AbstractProducer.prototype.ROYALE_COMPILE_FLAGS = 26;
