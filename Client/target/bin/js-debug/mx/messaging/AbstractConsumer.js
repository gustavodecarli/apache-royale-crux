/**
 * Generated by Apache Royale Compiler from mx/messaging/AbstractConsumer.as
 * mx.messaging.AbstractConsumer
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.messaging.AbstractConsumer');
/* Royale Dependency List: mx.core.mx_internal,mx.events.PropertyChangeEvent,mx.logging.Log,mx.messaging.ConsumerMessageDispatcher,mx.messaging.channels.PollingChannel,mx.messaging.errors.ArgumentError,mx.messaging.events.ChannelEvent,mx.messaging.events.ChannelFaultEvent,mx.messaging.events.MessageEvent,mx.messaging.events.MessageFaultEvent,mx.messaging.messages.AcknowledgeMessage,mx.messaging.messages.CommandMessage,mx.messaging.messages.ErrorMessage,mx.messaging.messages.IMessage,mx.resources.IResourceManager,mx.resources.ResourceManager,org.apache.royale.events.Event,org.apache.royale.utils.Timer,org.apache.royale.utils.Language,XML*/

goog.require('mx.messaging.MessageAgent');



/**
 *  Constructs a Consumer.
 *
 *
 *  @example
 *  <listing version="3.0">
 *   function initConsumer():void
 *   {
 *       var consumer:Consumer = new Consumer();
 *       consumer.destination = "NASDAQ";
 *       consumer.selector = "operation IN ('Bid','Ask')";
 *       consumer.addEventListener(MessageEvent.MESSAGE, messageHandler);
 *       consumer.subscribe();
 *   }
 *
 *   function messageHandler(event:MessageEvent):void
 *   {
 *       var msg:IMessage = event.message;
 *       var info:Object = msg.body;
 *       trace("-App recieved message: " + msg.toString());
 *   }
 *   </listing>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @constructor
 * @extends {mx.messaging.MessageAgent}
 */
mx.messaging.AbstractConsumer = function() {
  
  this.mx_messaging_AbstractConsumer_resourceManager = mx.resources.ResourceManager.getInstance();
  mx.messaging.AbstractConsumer.base(this, 'constructor');
  this._log = mx.logging.Log.getLogger("mx.messaging.Consumer");
  this._agentType = "consumer";
};
goog.inherits(mx.messaging.AbstractConsumer, mx.messaging.MessageAgent);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.AbstractConsumer', mx.messaging.AbstractConsumer);


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__currentAttempt = 0;


/**
 * @private
 * @type {org.apache.royale.utils.Timer}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__resubscribeTimer;


/**
 * @export
 * @type {boolean}
 */
mx.messaging.AbstractConsumer.prototype._shouldBeSubscribed;


/**
 * @private
 * @type {mx.messaging.messages.CommandMessage}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__subscribeMsg;


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer_resourceManager;


/**
 *  @asprivate
 *  If our clientId has changed we may need to unsubscribe() using the
 *  current clientId and then resubscribe using the new clientId.
 *  // TODO - remove this?
 *
 *  @asparam value The clientId value.
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.http_$$www_adobe_com$2006$flex$mx$internal__setClientId = function(value) {
  if (mx.messaging.AbstractConsumer.superClass_.get__clientId.apply(this) != value) {
    var /** @type {boolean} */ resetSubscription = false;
    if (this.subscribed) {
      this.unsubscribe();
      resetSubscription = true;
    }
    mx.messaging.AbstractConsumer.superClass_.http_$$www_adobe_com$2006$flex$mx$internal__setClientId.apply(this, [ value] );
    if (resetSubscription)
      this.subscribe(value);
  }
};


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__maxFrequency = 0;


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__resubscribeAttempts = 5;


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__resubscribeInterval = 5000;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__subscribed;


/**
 *  @asprivate
 * @export
 * @param {boolean} value
 */
mx.messaging.AbstractConsumer.prototype.setSubscribed = function(value) {
  if (this.mx_messaging_AbstractConsumer__subscribed != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "subscribed", this.mx_messaging_AbstractConsumer__subscribed, value);
    this.mx_messaging_AbstractConsumer__subscribed = value;
    if (this.mx_messaging_AbstractConsumer__subscribed) {
      mx.messaging.ConsumerMessageDispatcher.getInstance().registerSubscription(this);
      if (this.channelSet != null && this.channelSet.currentChannel != null && org.apache.royale.utils.Language.is(this.channelSet.currentChannel, mx.messaging.channels.PollingChannel))
        org.apache.royale.utils.Language.as(this.channelSet.currentChannel, mx.messaging.channels.PollingChannel, true).enablePolling();
    } else {
      mx.messaging.ConsumerMessageDispatcher.getInstance().unregisterSubscription(this);
      if (this.channelSet != null && this.channelSet.currentChannel != null && org.apache.royale.utils.Language.is(this.channelSet.currentChannel, mx.messaging.channels.PollingChannel))
        org.apache.royale.utils.Language.as(this.channelSet.currentChannel, mx.messaging.channels.PollingChannel, true).disablePolling();
    }
    this.dispatchEvent(event);
  }
};


/**
 * @private
 * @type {number}
 */
mx.messaging.AbstractConsumer.prototype.mx_messaging_AbstractConsumer__timestamp = -1;


/**
 *  @asprivate
 *  Custom processing for subscribe, unsubscribe and poll message
 *  acknowledgments.
 *
 *  @asparam ackMsg The AcknowledgeMessage.
 *
 *  @asparam msg The original subscribe, unsubscribe or poll message.
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.acknowledge = function(ackMsg, msg) {
  if (this._disconnectBarrier)
    return;
  if (!ackMsg.headers[mx.messaging.messages.AcknowledgeMessage.ERROR_HINT_HEADER] && org.apache.royale.utils.Language.is(msg, mx.messaging.messages.CommandMessage)) {
    var /** @type {mx.messaging.messages.CommandMessage} */ command = org.apache.royale.utils.Language.as(msg, mx.messaging.messages.CommandMessage);
    var /** @type {number} */ op = (command.operation) >> 0;
    if (op == mx.messaging.messages.CommandMessage.MULTI_SUBSCRIBE_OPERATION) {
      if (msg.headers.DSlastUnsub != null)
        op = (mx.messaging.messages.CommandMessage.UNSUBSCRIBE_OPERATION) >> 0;
      else
        op = (mx.messaging.messages.CommandMessage.SUBSCRIBE_OPERATION) >> 0;
    }
    switch (op) {
      case mx.messaging.messages.CommandMessage.UNSUBSCRIBE_OPERATION:
        if (mx.logging.Log.isInfo())
          this._log.info("'{0}' {1} acknowledge for unsubscribe.", this.id, this._agentType);
        mx.messaging.AbstractConsumer.superClass_.http_$$www_adobe_com$2006$flex$mx$internal__setClientId.apply(this, [ null] );
        this.setSubscribed(false);
        ackMsg.clientId = null;
        mx.messaging.AbstractConsumer.superClass_.acknowledge.apply(this, [ ackMsg, msg] );
        break;
      case mx.messaging.messages.CommandMessage.SUBSCRIBE_OPERATION:
        this.stopResubscribeTimer();
        if (ackMsg.timestamp > this.mx_messaging_AbstractConsumer__timestamp)
          this.mx_messaging_AbstractConsumer__timestamp = ackMsg.timestamp - 1;
        if (mx.logging.Log.isInfo())
          this._log.info("'{0}' {1} acknowledge for subscribe. Client id '{2}' new timestamp {3}", this.id, this._agentType, ackMsg.clientId, this.mx_messaging_AbstractConsumer__timestamp);
        mx.messaging.AbstractConsumer.superClass_.http_$$www_adobe_com$2006$flex$mx$internal__setClientId.apply(this, [ ackMsg.clientId] );
        this.setSubscribed(true);
        mx.messaging.AbstractConsumer.superClass_.acknowledge.apply(this, [ ackMsg, msg] );
        break;
      case mx.messaging.messages.CommandMessage.POLL_OPERATION:
        if ((ackMsg.body != null) && org.apache.royale.utils.Language.is(ackMsg.body, Array)) {
          var /** @type {Array} */ messageList = org.apache.royale.utils.Language.as(ackMsg.body, Array);
          var foreachiter0_target = messageList;
          for (var foreachiter0 in foreachiter0_target) 
          {
          var message = foreachiter0_target[foreachiter0];
          
            this.http_$$www_adobe_com$2006$flex$mx$internal__messageHandler(mx.messaging.events.MessageEvent.createEvent(mx.messaging.events.MessageEvent.MESSAGE, message));}
          
        }
        mx.messaging.AbstractConsumer.superClass_.acknowledge.apply(this, [ ackMsg, msg] );
        break;
    }
  } else {
    mx.messaging.AbstractConsumer.superClass_.acknowledge.apply(this, [ ackMsg, msg] );
  }
};


/**
 *  Disconnects the Consumer from its remote destination.
 *  This method should be invoked on a Consumer that is no longer
 *  needed by an application after unsubscribing.
 *  This method does not wait for outstanding network operations to complete
 *  and does not send an unsubscribe message to the server.
 *  After invoking disconnect(), the Consumer will report that it is in an
 *  disconnected, unsubscribed state because it will not receive any more
 *  messages until it has reconnected and resubscribed.
 *  Disconnecting stops automatic resubscription attempts if they are running.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.disconnect = function() {
  this._shouldBeSubscribed = false;
  this.stopResubscribeTimer();
  this.setSubscribed(false);
  mx.messaging.AbstractConsumer.superClass_.disconnect.apply(this);
};


/**
 *  @asprivate
 *  The Consumer supresses ErrorMessage processing if the error is
 *  retryable and it is configured to resubscribe.
 *
 *  @asparam errMsg The ErrorMessage describing the fault.
 *
 *  @asparam msg The original message (generally a subscribe).
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.fault = function(errMsg, msg) {
  if (this._disconnectBarrier)
    return;
  if (errMsg.headers[mx.messaging.messages.ErrorMessage.RETRYABLE_HINT_HEADER]) {
    if (this.mx_messaging_AbstractConsumer__resubscribeTimer == null) {
      if ((this.mx_messaging_AbstractConsumer__subscribeMsg != null) && (errMsg.correlationId == this.mx_messaging_AbstractConsumer__subscribeMsg.messageId))
        this._shouldBeSubscribed = false;
      mx.messaging.AbstractConsumer.superClass_.fault.apply(this, [ errMsg, msg] );
    }
  } else {
    mx.messaging.AbstractConsumer.superClass_.fault.apply(this, [ errMsg, msg] );
  }
};


/**
 *  @asprivate
 *  Custom processing to warn the user if the consumer is connected over
 *  a non-real channel.
 *
 *  @asparam event The ChannelEvent.
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.channelConnectHandler = function(event) {
  mx.messaging.AbstractConsumer.superClass_.channelConnectHandler.apply(this, [ event] );
  if (this.connected && this.channelSet != null && this.channelSet.currentChannel != null && !this.channelSet.currentChannel.http_$$www_adobe_com$2006$flex$mx$internal__realtime && mx.logging.Log.isWarn()) {
    this._log.warn("'{0}' {1} connected over a non-realtime channel '{2}'" + " which means channel is not automatically receiving updates via polling or server push.", this.id, this._agentType, this.channelSet.currentChannel.id);
  }
};


/**
 *  @asprivate
 *  Custom processing to start up a resubscribe timer if our channel is
 *  disconnected when we should be subscribed.
 *
 *  @asparam event The ChannelEvent.
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.channelDisconnectHandler = function(event) {
  this.setSubscribed(false);
  mx.messaging.AbstractConsumer.superClass_.channelDisconnectHandler.apply(this, [ event] );
  if (this._shouldBeSubscribed && !event.rejected)
    this.startResubscribeTimer();
};


/**
 *  @asprivate
 *  Custom processing to start up a resubscribe timer if our channel faults
 *  when we should be subscribed.
 *
 *  @asparam event The ChannelFaultEvent.
 * @export
 * @override
 */
mx.messaging.AbstractConsumer.prototype.channelFaultHandler = function(event) {
  if (!event.channel.connected)
    this.setSubscribed(false);
  mx.messaging.AbstractConsumer.superClass_.channelFaultHandler.apply(this, [ event] );
  if (this._shouldBeSubscribed && !event.rejected && !event.channel.connected)
    this.startResubscribeTimer();
};


/**
 *  Requests any messages that are queued for this Consumer on the server.
 *  This method should only be used for Consumers that subscribe over non-realtime,
 *  non-polling channels.
 *  This method is a no-op if the Consumer is not subscribed.
 *
 *  @asparam timestamp This argument is deprecated and is ignored.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {number=} timestamp
 */
mx.messaging.AbstractConsumer.prototype.receive = function(timestamp) {
  timestamp = typeof timestamp !== 'undefined' ? timestamp : 0;
  if (this.clientId != null) {
    var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
    msg.operation = mx.messaging.messages.CommandMessage.POLL_OPERATION;
    msg.destination = this.destination;
    this.internalSend(msg);
  }
};


/**
 *  Subscribes to the remote destination.
 *
 *  @asparam clientId The client id to subscribe with. Use null for non-durable Consumers. If the subscription is durable, a consistent
 *                  value must be supplied every time the Consumer subscribes in order
 *                  to reconnect to the correct durable subscription in the remote destination.
 *
 *  @throws mx.messaging.errors.InvalidDestinationError If no destination is set.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {string=} clientId
 */
mx.messaging.AbstractConsumer.prototype.subscribe = function(clientId) {
  clientId = typeof clientId !== 'undefined' ? clientId : null;
  var /** @type {boolean} */ resetClientId = ((clientId != null) && (mx.messaging.AbstractConsumer.superClass_.get__clientId.apply(this) != clientId)) ? true : false;
  if (this.subscribed && resetClientId) {
    this.unsubscribe();
  }
  this.stopResubscribeTimer();
  this._shouldBeSubscribed = true;
  if (resetClientId)
    mx.messaging.AbstractConsumer.superClass_.http_$$www_adobe_com$2006$flex$mx$internal__setClientId.apply(this, [ clientId] );
  if (mx.logging.Log.isInfo())
    this._log.info("'{0}' {1} subscribe.", this.id, this._agentType);
  this.mx_messaging_AbstractConsumer__subscribeMsg = this.buildSubscribeMessage();
  this.internalSend(this.mx_messaging_AbstractConsumer__subscribeMsg);
};


/**
 *  Unsubscribes from the remote destination. In the case of durable JMS
 *  subscriptions, this will destroy the durable subscription on the JMS server.
 *
 *  @asparam preserveDurable - when true, durable JMS subscriptions are not destroyed
 *      allowing consumers to later resubscribe and receive missed messages
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {boolean=} preserveDurable
 */
mx.messaging.AbstractConsumer.prototype.unsubscribe = function(preserveDurable) {
  preserveDurable = typeof preserveDurable !== 'undefined' ? preserveDurable : false;
  this._shouldBeSubscribed = false;
  if (this.subscribed) {
    if (this.channelSet != null)
      this.channelSet.removeEventListener(this.destination, org.apache.royale.utils.Language.closure(this.http_$$www_adobe_com$2006$flex$mx$internal__messageHandler, this, 'http://www.adobe.com/2006/flex/mx/internal::messageHandler'));
    if (mx.logging.Log.isInfo())
      this._log.info("'{0}' {1} unsubscribe.", this.id, this._agentType);
    this.internalSend(this.buildUnsubscribeMessage(preserveDurable));
  } else {
    this.stopResubscribeTimer();
  }
};


/**
 *  @asprivate
 *  Consumers subscribe for messages from a destination and this is the handler
 *  method that is invoked when a message for this Consumer is pushed or polled
 *  from the server.
 *
 *  @asparam event The MessageEvent.
 * @export
 * @param {mx.messaging.events.MessageEvent} event
 */
mx.messaging.AbstractConsumer.prototype.http_$$www_adobe_com$2006$flex$mx$internal__messageHandler = function(event) {
  var /** @type {mx.messaging.messages.IMessage} */ message = event.message;
  if (org.apache.royale.utils.Language.is(message, mx.messaging.messages.CommandMessage)) {
    var /** @type {mx.messaging.messages.CommandMessage} */ command = org.apache.royale.utils.Language.as(message, mx.messaging.messages.CommandMessage);
    switch (command.operation) {
      case mx.messaging.messages.CommandMessage.SUBSCRIPTION_INVALIDATE_OPERATION:
        this.setSubscribed(false);
        break;
      default:
        if (mx.logging.Log.isWarn())
          this._log.warn("'{0}' received a CommandMessage '{1}' that could not be handled.", this.id, mx.messaging.messages.CommandMessage.getOperationAsString(command.operation));
    }
    return;
  }
  if (message.timestamp > this.mx_messaging_AbstractConsumer__timestamp)
    this.mx_messaging_AbstractConsumer__timestamp = message.timestamp;
  if (org.apache.royale.utils.Language.is(message, mx.messaging.messages.ErrorMessage))
    this.dispatchEvent(mx.messaging.events.MessageFaultEvent.createEvent(org.apache.royale.utils.Language.as(message, mx.messaging.messages.ErrorMessage, true)));
  else
    this.dispatchEvent(mx.messaging.events.MessageEvent.createEvent(mx.messaging.events.MessageEvent.MESSAGE, message));
};


/**
 *  Returns a subscribe message.
 *  This method should be overridden by subclasses if they need custom
 *  subscribe messages.
 *
 *  @asreturn The subscribe CommandMessage.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @return {mx.messaging.messages.CommandMessage}
 */
mx.messaging.AbstractConsumer.prototype.buildSubscribeMessage = function() {
  var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
  msg.operation = mx.messaging.messages.CommandMessage.SUBSCRIBE_OPERATION;
  msg.clientId = this.clientId;
  msg.destination = this.destination;
  if (this.maxFrequency > 0)
    msg.headers[mx.messaging.messages.CommandMessage.MAX_FREQUENCY_HEADER] = this.maxFrequency;
  return msg;
};


/**
 *  Returns an unsubscribe message.
 *  This method should be overridden by subclasses if they need custom
 *  unsubscribe messages.
 *
 *  @asparam preserveDurable - when true, durable JMS subscriptions are not destroyed
 *          allowing consumers to later resubscribe and receive missed messages
 *
 *  @asreturn The unsubscribe CommandMessage.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {boolean} preserveDurable
 * @return {mx.messaging.messages.CommandMessage}
 */
mx.messaging.AbstractConsumer.prototype.buildUnsubscribeMessage = function(preserveDurable) {
  var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
  msg.operation = mx.messaging.messages.CommandMessage.UNSUBSCRIBE_OPERATION;
  msg.clientId = this.clientId;
  msg.destination = this.destination;
  if (preserveDurable)
    msg.headers[mx.messaging.messages.CommandMessage.PRESERVE_DURABLE_HEADER] = preserveDurable;
  return msg;
};


/**
 *  @asprivate
 *  Attempt to resubscribe.
 *  This can be called directly or from a Timer's event handler.
 *
 *  @asparam event The timer event for resubscribe attempts.
 * @export
 * @param {org.apache.royale.events.Event} event
 */
mx.messaging.AbstractConsumer.prototype.resubscribe = function(event) {
  if ((this.mx_messaging_AbstractConsumer__resubscribeAttempts != -1) && (this.mx_messaging_AbstractConsumer__currentAttempt >= this.mx_messaging_AbstractConsumer__resubscribeAttempts)) {
    this.stopResubscribeTimer();
    this._shouldBeSubscribed = false;
    var /** @type {mx.messaging.messages.ErrorMessage} */ errMsg = new mx.messaging.messages.ErrorMessage();
    errMsg.faultCode = "Client.Error.Subscribe";
    errMsg.faultString = this.mx_messaging_AbstractConsumer_resourceManager.getString("messaging", "consumerSubscribeError");
    errMsg.faultDetail = this.mx_messaging_AbstractConsumer_resourceManager.getString("messaging", "failedToSubscribe");
    errMsg.correlationId = this.mx_messaging_AbstractConsumer__subscribeMsg.messageId;
    this.fault(errMsg, this.mx_messaging_AbstractConsumer__subscribeMsg);
    return;
  }
  if (mx.logging.Log.isDebug())
    this._log.debug("'{0}' {1} trying to resubscribe.", this.id, this._agentType);
  this.mx_messaging_AbstractConsumer__resubscribeTimer.delay = this.mx_messaging_AbstractConsumer__resubscribeInterval;
  this.mx_messaging_AbstractConsumer__currentAttempt++;
  this.internalSend(this.mx_messaging_AbstractConsumer__subscribeMsg, false);
};


/**
 *  @asprivate
 *  This method will start a timer which attempts to resubscribe
 *  periodically.
 * @export
 */
mx.messaging.AbstractConsumer.prototype.startResubscribeTimer = function() {
  if (this._shouldBeSubscribed && (this.mx_messaging_AbstractConsumer__resubscribeTimer == null)) {
    if ((this.mx_messaging_AbstractConsumer__resubscribeAttempts != 0) && (this.mx_messaging_AbstractConsumer__resubscribeInterval > 0)) {
      if (mx.logging.Log.isDebug())
        this._log.debug("'{0}' {1} starting resubscribe timer.", this.id, this._agentType);
      this.mx_messaging_AbstractConsumer__resubscribeTimer = new org.apache.royale.utils.Timer(1);
      this.mx_messaging_AbstractConsumer__resubscribeTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.resubscribe, this, 'resubscribe'));
      this.mx_messaging_AbstractConsumer__resubscribeTimer.start();
      this.mx_messaging_AbstractConsumer__currentAttempt = 0;
    }
  }
};


/**
 * @asprivate
 * Stops a resubscribe timer if one is running.
 * @export
 */
mx.messaging.AbstractConsumer.prototype.stopResubscribeTimer = function() {
  if (this.mx_messaging_AbstractConsumer__resubscribeTimer != null) {
    if (mx.logging.Log.isDebug())
      this._log.debug("'{0}' {1} stopping resubscribe timer.", this.id, this._agentType);
    this.mx_messaging_AbstractConsumer__resubscribeTimer.removeEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.resubscribe, this, 'resubscribe'));
    this.mx_messaging_AbstractConsumer__resubscribeTimer.reset();
    this.mx_messaging_AbstractConsumer__resubscribeTimer = null;
  }
};


mx.messaging.AbstractConsumer.prototype.set__destination = function(value) {
  if (this.destination != value) {
    var /** @type {boolean} */ resetSubscription = false;
    if (this.subscribed) {
      this.unsubscribe();
      resetSubscription = true;
    }
    mx.messaging.AbstractConsumer.superClass_.set__destination.apply(this, [ value] );
    if (resetSubscription)
      this.subscribe();
  }
};


mx.messaging.AbstractConsumer.prototype.get__maxFrequency = function() {
  return this.mx_messaging_AbstractConsumer__maxFrequency;
};


mx.messaging.AbstractConsumer.prototype.set__maxFrequency = function(value) {
  var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "maxFrequency", this.mx_messaging_AbstractConsumer__maxFrequency, value);
  this.mx_messaging_AbstractConsumer__maxFrequency = value;
  this.dispatchEvent(event);
};


mx.messaging.AbstractConsumer.prototype.get__resubscribeAttempts = function() {
  return this.mx_messaging_AbstractConsumer__resubscribeAttempts;
};


mx.messaging.AbstractConsumer.prototype.set__resubscribeAttempts = function(value) {
  if (this.mx_messaging_AbstractConsumer__resubscribeAttempts != value) {
    if (value == 0)
      this.stopResubscribeTimer();
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "resubscribeAttempts", this.mx_messaging_AbstractConsumer__resubscribeAttempts, value);
    this.mx_messaging_AbstractConsumer__resubscribeAttempts = value;
    this.dispatchEvent(event);
  }
};


mx.messaging.AbstractConsumer.prototype.get__resubscribeInterval = function() {
  return this.mx_messaging_AbstractConsumer__resubscribeInterval;
};


mx.messaging.AbstractConsumer.prototype.set__resubscribeInterval = function(value) {
  if (this.mx_messaging_AbstractConsumer__resubscribeInterval != value) {
    if (value < 0) {
      var /** @type {string} */ message = this.mx_messaging_AbstractConsumer_resourceManager.getString("messaging", "resubscribeIntervalNegative");
      throw new mx.messaging.errors.ArgumentError(message);
    } else if (value == 0) {
      this.stopResubscribeTimer();
    } else if (this.mx_messaging_AbstractConsumer__resubscribeTimer != null) {
      this.mx_messaging_AbstractConsumer__resubscribeTimer.delay = value;
    }
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "resubscribeInterval", this.mx_messaging_AbstractConsumer__resubscribeInterval, value);
    this.mx_messaging_AbstractConsumer__resubscribeInterval = value;
    this.dispatchEvent(event);
  }
};


mx.messaging.AbstractConsumer.prototype.get__subscribed = function() {
  return this.mx_messaging_AbstractConsumer__subscribed;
};


mx.messaging.AbstractConsumer.prototype.get__timestamp = function() {
  return this.mx_messaging_AbstractConsumer__timestamp;
};


mx.messaging.AbstractConsumer.prototype.set__timestamp = function(value) {
  if (this.mx_messaging_AbstractConsumer__timestamp != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "timestamp", this.mx_messaging_AbstractConsumer__timestamp, value);
    this.mx_messaging_AbstractConsumer__timestamp = value;
    this.dispatchEvent(event);
  }
};


Object.defineProperties(mx.messaging.AbstractConsumer.prototype, /** @lends {mx.messaging.AbstractConsumer.prototype} */ {
/**
  * @export
  * @type {string} */
destination: {
get: mx.messaging.MessageAgent.prototype.get__destination,
set: mx.messaging.AbstractConsumer.prototype.set__destination},
/**
  * @export
  * @type {number} */
maxFrequency: {
get: mx.messaging.AbstractConsumer.prototype.get__maxFrequency,
set: mx.messaging.AbstractConsumer.prototype.set__maxFrequency},
/**
  * @export
  * @type {number} */
resubscribeAttempts: {
get: mx.messaging.AbstractConsumer.prototype.get__resubscribeAttempts,
set: mx.messaging.AbstractConsumer.prototype.set__resubscribeAttempts},
/**
  * @export
  * @type {number} */
resubscribeInterval: {
get: mx.messaging.AbstractConsumer.prototype.get__resubscribeInterval,
set: mx.messaging.AbstractConsumer.prototype.set__resubscribeInterval},
/**
  * @export
  * @type {boolean} */
subscribed: {
get: mx.messaging.AbstractConsumer.prototype.get__subscribed},
/**
  * @export
  * @type {number} */
timestamp: {
get: mx.messaging.AbstractConsumer.prototype.get__timestamp,
set: mx.messaging.AbstractConsumer.prototype.set__timestamp}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.AbstractConsumer.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'AbstractConsumer', qName: 'mx.messaging.AbstractConsumer', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.AbstractConsumer.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'destination': { type: 'String', access: 'writeonly', declaredBy: 'mx.messaging.AbstractConsumer'},
        'maxFrequency': { type: 'uint', access: 'readwrite', declaredBy: 'mx.messaging.AbstractConsumer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'resubscribeAttempts': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.AbstractConsumer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'resubscribeInterval': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.AbstractConsumer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'subscribed': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.AbstractConsumer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'timestamp': { type: 'Number', access: 'readwrite', declaredBy: 'mx.messaging.AbstractConsumer', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }}
      };
    },
    methods: function () {
      return {
        'AbstractConsumer': { type: '', declaredBy: 'mx.messaging.AbstractConsumer'},
        'http://www.adobe.com/2006/flex/mx/internal::setClientId': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'String', false ]; }},
        'acknowledge': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'mx.messaging.messages.AcknowledgeMessage', false ,'mx.messaging.messages.IMessage', false ]; }},
        'disconnect': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer'},
        'fault': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'mx.messaging.messages.ErrorMessage', false ,'mx.messaging.messages.IMessage', false ]; }},
        'channelConnectHandler': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'mx.messaging.events.ChannelEvent', false ]; }},
        'channelDisconnectHandler': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'mx.messaging.events.ChannelEvent', false ]; }},
        'channelFaultHandler': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'mx.messaging.events.ChannelFaultEvent', false ]; }},
        'receive': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'Number', true ]; }},
        'subscribe': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'String', true ]; }},
        'unsubscribe': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'Boolean', true ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::messageHandler': { type: 'void', declaredBy: 'mx.messaging.AbstractConsumer', parameters: function () { return [ 'mx.messaging.events.MessageEvent', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.AbstractConsumer.prototype.ROYALE_COMPILE_FLAGS = 26;
