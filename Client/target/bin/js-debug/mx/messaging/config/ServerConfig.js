/**
 * Generated by Apache Royale Compiler from mx/messaging/config/ServerConfig.as
 * mx.messaging.config.ServerConfig
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.messaging.config.ServerConfig');
/* Royale Dependency List: XML,XMLList,mx.collections.ArrayCollection,mx.core.mx_internal,mx.messaging.Channel,mx.messaging.ChannelSet,mx.messaging.MessageAgent,mx.messaging.config.ConfigMap,mx.messaging.config.LoaderConfig,mx.messaging.errors.ArgumentError,mx.messaging.errors.InvalidChannelError,mx.messaging.errors.InvalidDestinationError,mx.resources.IResourceManager,mx.resources.ResourceManager,mx.utils.ObjectUtil,org.apache.royale.reflection.getDefinitionByName,org.apache.royale.reflection.getQualifiedClassName,org.apache.royale.utils.Language*/




/**
 * @constructor
 */
mx.messaging.config.ServerConfig = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.config.ServerConfig', mx.messaging.config.ServerConfig);


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.config.ServerConfig.CLASS_ATTR = "type";


/**
 * @export
 * @const
 * @type {string}
 */
mx.messaging.config.ServerConfig.URI_ATTR = "uri";


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.messaging.config.ServerConfig._resourceManager;


/**
 * @export
 * @type {XML}
 */
mx.messaging.config.ServerConfig.serverConfigData;


/**
 * @private
 * @type {Object}
 */
mx.messaging.config.ServerConfig._channelSets = {};


/**
 * @private
 * @type {Object}
 */
mx.messaging.config.ServerConfig._clusteredChannels = {};


/**
 * @private
 * @type {Object}
 */
mx.messaging.config.ServerConfig._unclusteredChannels = {};


/**
 * @private
 * @type {Object}
 */
mx.messaging.config.ServerConfig._configFetchedChannels;


/**
 * @export
 * @type {Object}
 */
mx.messaging.config.ServerConfig.channelSetFactory;


/**
 *  This method ensures that the destinations specified contain identical
 *  channel definitions.
 *  If the channel definitions between the two destinations specified are
 *  not identical this method will throw an ArgumentError.
 *
 *  @asparam   destinationA:String first destination to compare against
 *  @asparam   destinationB:String second destination to compare channels with
 *  @throw   ArgumentError if the channel definitions of the specified
 *           destinations aren't identical.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {string} destinationA
 * @param {string} destinationB
 */
mx.messaging.config.ServerConfig.checkChannelConsistency = function(destinationA, destinationB) {
  var /** @type {Array} */ channelIdsA = mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__getChannelIdList(destinationA);
  var /** @type {Array} */ channelIdsB = mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__getChannelIdList(destinationB);
  if (mx.utils.ObjectUtil.compare(channelIdsA, channelIdsB) != 0)
    throw new mx.messaging.errors.ArgumentError("Specified destinations are not channel consistent");
};


/**
 *  Returns a shared instance of the configured Channel.
 *
 *  @asparam id The id of the desired Channel.
 *
 *  @asparam clustered True if the Channel will be used in a clustered
 *                   fashion; otherwise false.
 *
 *  @asreturn The Channel instance.
 *
 *  @throws mx.messaging.errors.InvalidChannelError If no Channel has the specified id.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {string} id
 * @param {boolean=} clustered
 * @return {mx.messaging.Channel}
 */
mx.messaging.config.ServerConfig.getChannel = function(id, clustered) {
  clustered = typeof clustered !== 'undefined' ? clustered : false;
  var /** @type {mx.messaging.Channel} */ channel;
  if (!clustered) {
    if (id in mx.messaging.config.ServerConfig._unclusteredChannels) {
      return mx.messaging.config.ServerConfig._unclusteredChannels[id];
    } else {
      channel = mx.messaging.config.ServerConfig.createChannel(id);
      mx.messaging.config.ServerConfig._unclusteredChannels[id] = channel;
      return channel;
    }
  } else {
    if (id in mx.messaging.config.ServerConfig._clusteredChannels) {
      return mx.messaging.config.ServerConfig._clusteredChannels[id];
    } else {
      channel = mx.messaging.config.ServerConfig.createChannel(id);
      mx.messaging.config.ServerConfig._clusteredChannels[id] = channel;
      return channel;
    }
  }
};


/**
 *  Returns a shared ChannelSet for use with the specified destination
 *  belonging to the service that handles the specified message type.
 *
 *  @asparam destinationId The target destination id.
 *
 *  @asreturn The ChannelSet.
 *
 *  @throws mx.messaging.errors.InvalidDestinationError If the specified destination
 *                                  does not have channels and the application
 *                                  did not define default channels.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {string} destinationId
 * @return {mx.messaging.ChannelSet}
 */
mx.messaging.config.ServerConfig.getChannelSet = function(destinationId) {
  var /** @type {XML} */ destinationConfig = mx.messaging.config.ServerConfig.getDestinationConfig(destinationId);
  return mx.messaging.config.ServerConfig.internalGetChannelSet(destinationConfig, destinationId);
};


/**
 *  Returns the property information for the specified destination
 *
 *  @asparam destinationId The id of the desired destination.
 *
 *  @asreturn XMLList containing the &lt;property&gt; tag information.
 *
 *  @throws mx.messaging.errors.InvalidDestinationError If the specified destination is not found.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {string} destinationId
 * @return {XMLList}
 */
mx.messaging.config.ServerConfig.getProperties = function(destinationId) {
  var /** @type {XMLList} */ destination = mx.messaging.config.ServerConfig["xml"].descendants('destination').filter(function(/** @type {XML} */ node){return (node.attribute('id') == destinationId)});
  if (destination.length() == 0) {
    var /** @type {string} */ message = mx.messaging.config.ServerConfig["resourceManager"].getString("messaging", "unknownDestination", [destinationId]);
    throw new mx.messaging.errors.InvalidDestinationError(message);
  }
  return destination.child('properties');
};


/**
 *  This method returns true iff the channelset specified has channels with
 *  ids or uris that match those found in the destination specified.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @export
 * @param {mx.messaging.ChannelSet} channelSet
 * @param {string} destination
 * @return {boolean}
 */
mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__channelSetMatchesDestinationConfig = function(channelSet, destination) {
  if (channelSet != null) {
    if (mx.utils.ObjectUtil.compare(channelSet.channelIds, mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__getChannelIdList(destination)) == 0)
      return true;
    var /** @type {Array} */ csUris = [];
    var /** @type {Array} */ csChannels = channelSet.channels;
    for (var /** @type {number} */ i = 0; i < csChannels.length; i++)
      csUris.push(csChannels[i].uri);
    var /** @type {Array} */ ids = mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__getChannelIdList(destination);
    var /** @type {Array} */ dsUris = [];
    var /** @type {XMLList} */ dsChannels;
    var /** @type {XML} */ channelConfig;
    var /** @type {XML} */ endpoint;
    var /** @type {string} */ dsUri;
    for (var /** @type {number} */ j = 0; j < ids.length; j++) {
      dsChannels = mx.messaging.config.ServerConfig["xml"].child('channels').child('channel').filter(function(/** @type {XML} */ node){return (node.attribute('id') == ids[j])});
      channelConfig = dsChannels[0];
      endpoint = channelConfig.child('endpoint');
      dsUri = org.apache.royale.utils.Language.string(endpoint.length() > 0 ? endpoint[0].attribute(mx.messaging.config.ServerConfig.URI_ATTR).toString() : null);
      if (!dsUri)
        dsUri = org.apache.royale.utils.Language.string(endpoint.length() > 0 ? endpoint[0].attribute("url").toString() : null);
      if (dsUri != null)
        dsUris.push(dsUri);
    }
    return mx.utils.ObjectUtil.compare(csUris, dsUris) == 0;
  }
  return false;
};


/**
 * @asprivate
 * returns if the specified endpoint has been fetched already
 * @export
 * @param {string} endpoint
 * @return {boolean}
 */
mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__fetchedConfig = function(endpoint) {
  return mx.messaging.config.ServerConfig._configFetchedChannels != null && mx.messaging.config.ServerConfig._configFetchedChannels[endpoint] != null;
};


/**
 *  @asprivate
 *  This method returns a list of the channel ids for the given destination
 *  configuration. If no channels exist for the destination, it returns a
 *  list of default channel ids for the applcation
 * @export
 * @param {string} destination
 * @return {Array}
 */
mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__getChannelIdList = function(destination) {
  var /** @type {XML} */ destinationConfig = mx.messaging.config.ServerConfig.getDestinationConfig(destination);
  return destinationConfig ? mx.messaging.config.ServerConfig.getChannelIds(destinationConfig) : mx.messaging.config.ServerConfig.getDefaultChannelIds();
};


/**
 *  @asprivate
 *  Used by the Channels to determine whether the Channel should request
 *  dynamic configuration from the server for its MessageAgents.
 * @export
 * @param {mx.messaging.Channel} channel
 * @return {boolean}
 */
mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__needsConfig = function(channel) {
  if (mx.messaging.config.ServerConfig._configFetchedChannels == null || mx.messaging.config.ServerConfig._configFetchedChannels[channel.endpoint] == null) {
    var /** @type {Array} */ channelSets = channel.channelSets;
    var /** @type {number} */ m = (channelSets.length) >> 0;
    for (var /** @type {number} */ i = 0; i < m; i++) {
      if (org.apache.royale.reflection.getQualifiedClassName(channelSets[i]).indexOf("Advanced") != -1)
        return true;
      var /** @type {Array} */ messageAgents = org.apache.royale.utils.Language.as(channelSets[i], mx.messaging.ChannelSet, true).messageAgents;
      var /** @type {number} */ n = (messageAgents.length) >> 0;
      for (var /** @type {number} */ j = 0; j < n; j++) {
        if (org.apache.royale.utils.Language.as(messageAgents[j], mx.messaging.MessageAgent, true).http_$$www_adobe_com$2006$flex$mx$internal__needsConfig)
          return true;
      }
    }
  }
  return false;
};


/**
 *  @asprivate
 *  This method updates the xml with serverConfig object returned from the
 *  server during initial client connect
 * @export
 * @param {mx.messaging.config.ConfigMap} serverConfig
 * @param {string=} endpoint
 */
mx.messaging.config.ServerConfig.http_$$www_adobe_com$2006$flex$mx$internal__updateServerConfigData = function(serverConfig, endpoint) {
  endpoint = typeof endpoint !== 'undefined' ? endpoint : null;
  if (serverConfig != null) {
    if (endpoint != null) {
      if (mx.messaging.config.ServerConfig._configFetchedChannels == null)
        mx.messaging.config.ServerConfig._configFetchedChannels = {};
      mx.messaging.config.ServerConfig._configFetchedChannels[endpoint] = true;
    }
    var /** @type {XML} */ newServices = new XML( '<services></services>');
    mx.messaging.config.ServerConfig.convertToXML(serverConfig, newServices);
    mx.messaging.config.ServerConfig["xml"].setChild('default-channels', newServices.child("default-channels"));
    var foreachiter0_target = newServices.descendants('service');
    for (var foreachiter0 in foreachiter0_target.elementNames()) 
    {
    var newService = foreachiter0_target[foreachiter0];
    {
      var /** @type {XMLList} */ oldServices = mx.messaging.config.ServerConfig["xml"].child('service').filter(function(/** @type {XML} */ node){return (node.attribute('id') == node.newService.attribute('id'))});
      var /** @type {XMLList} */ oldDestinations;
      var /** @type {XML} */ newDestination;
      if (oldServices.length() != 0) {
        var /** @type {XML} */ oldService = oldServices[0];
        var foreachiter1_target = newService.descendants('destination');
        for (var foreachiter1 in foreachiter1_target.elementNames()) 
        {
        newDestination = foreachiter1_target[foreachiter1];
        {
          oldDestinations = oldService.child('destination').filter(function(/** @type {XML} */ node){return (node.attribute('id') == newDestination.attribute('id'))});
          if (oldDestinations.length() != 0)
            oldDestinations.removeChild(0);
          oldService.appendChild(newDestination.copy());
        }}
        
      } else {
        var foreachiter2_target = newService.descendants('destination');
        for (var foreachiter2 in foreachiter2_target.elementNames()) 
        {
        newDestination = foreachiter2_target[foreachiter2];
        {
          oldDestinations = mx.messaging.config.ServerConfig["xml"].descendants('destination').filter(function(/** @type {XML} */ node){return (node.attribute('id') == newDestination.attribute('id'))});
          if (oldDestinations.length() != 0) {
            oldDestinations[0] = newDestination[0].copy();
            delete newService.descendants('destination').filter(function(/** @type {XML} */ node){return (node.attribute('id') == newDestination.attribute('id'))})[0];
          }
        }}
        
        if (newService.children().length() > 0)
          mx.messaging.config.ServerConfig["xml"].appendChild(newService);
      }
    }}
    
    var /** @type {XMLList} */ newChannels = newServices.child('channels');
    if (newChannels.length() > 0) {
      var /** @type {XML} */ oldChannels = mx.messaging.config.ServerConfig["xml"].child('channels')[0];
      if (oldChannels == null || oldChannels.length() == 0) {
        mx.messaging.config.ServerConfig["xml"].appendChild(newChannels);
      }
    }
  }
};


/**
 *  Helper method that builds a new Channel instance based on the
 *  configuration for the specified id.
 *
 *  @asparam id The id for the configured Channel to build.
 *
 *  @asreturn The Channel instance.
 *
 *  @throws mx.messaging.errors.InvalidChannelError If no configuration data for the specified
 *                             id exists.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @private
 * @param {string} channelId
 * @return {mx.messaging.Channel}
 */
mx.messaging.config.ServerConfig.createChannel = function(channelId) {
  var /** @type {string} */ message;
  var /** @type {XMLList} */ channels = mx.messaging.config.ServerConfig["xml"].child('channels').child('channel').filter(function(/** @type {XML} */ node){return (node.attribute('id') == channelId)});
  if (channels.length() == 0) {
    channels = mx.messaging.config.ServerConfig["xml"].child('channels').child("channel-definition").filter(function(/** @type {XML} */ node){return (node.attribute('id') == channelId)});
    if (channels.length() == 0) {
      message = mx.messaging.config.ServerConfig["resourceManager"].getString("messaging", "unknownChannelWithId", [channelId]);
      throw new mx.messaging.errors.InvalidChannelError(message);
    }
  }
  var /** @type {XML} */ channelConfig = channels[0];
  var /** @type {string} */ className = channelConfig.attribute(mx.messaging.config.ServerConfig.CLASS_ATTR).toString();
  if (!className)
    className = channelConfig.attribute("class").toString();
  var /** @type {XMLList} */ endpoint = channelConfig.child('endpoint');
  var /** @type {string} */ uri = org.apache.royale.utils.Language.string(endpoint.length() > 0 ? endpoint[0].attribute(mx.messaging.config.ServerConfig.URI_ATTR).toString() : null);
  if (!uri)
    uri = org.apache.royale.utils.Language.string(endpoint.length() > 0 ? endpoint[0].attribute("url").toString() : null);
  var /** @type {mx.messaging.Channel} */ channel = null;
  try {
    var /** @type {Object} */ channelClass = org.apache.royale.utils.Language.as(org.apache.royale.reflection.getDefinitionByName(className), org.apache.royale.utils.Language.synthType('Class'));
    channel = new channelClass(channelId, uri);
    channel.applySettings(channelConfig);
    if (mx.messaging.config.LoaderConfig["parameters"] != null && mx.messaging.config.LoaderConfig["parameters"].WSRP_ENCODED_CHANNEL != null)
      channel.url = org.apache.royale.utils.Language.string(mx.messaging.config.LoaderConfig["parameters"].WSRP_ENCODED_CHANNEL);
  } catch (e) {
    message = mx.messaging.config.ServerConfig["resourceManager"].getString("messaging", "unknownChannelClass", [className]);
    throw new mx.messaging.errors.InvalidChannelError(message);
  }
  return channel;
};


/**
 * Converts the ConfigMap of properties into XML
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @private
 * @param {mx.messaging.config.ConfigMap} config
 * @param {XML} configXML
 */
mx.messaging.config.ServerConfig.convertToXML = function(config, configXML) {
  for (var /** @type {Object} */ propertyKey in config.propertyNames()) {
    var /** @type {Object} */ propertyValue = config.getProperty(propertyKey);
    if (org.apache.royale.utils.Language.is(propertyValue, String)) {
      if (propertyKey == "") {
        configXML.appendChild(propertyValue);
      } else {
        configXML.setAttribute(propertyKey, propertyValue);
      }
    } else if (org.apache.royale.utils.Language.is(propertyValue, mx.collections.ArrayCollection) || org.apache.royale.utils.Language.is(propertyValue, Array)) {
      var /** @type {Array} */ propertyValueList;
      if (org.apache.royale.utils.Language.is(propertyValue, mx.collections.ArrayCollection))
        propertyValueList = org.apache.royale.utils.Language.as(propertyValue, mx.collections.ArrayCollection, true).toArray();
      else
        propertyValueList = org.apache.royale.utils.Language.as(propertyValue, Array);
      for (var /** @type {number} */ i = 0; i < propertyValueList.length; i++) {
        var /** @type {XML} */ propertyXML1 = new XML( '<' + propertyKey + '></' + propertyKey + '>                    ');
        configXML.appendChild(propertyXML1);
        mx.messaging.config.ServerConfig.convertToXML(org.apache.royale.utils.Language.as(propertyValueList[i], mx.messaging.config.ConfigMap), propertyXML1);
      }
    } else {
      var /** @type {XML} */ propertyXML2 = new XML( '<' + propertyKey + '></' + propertyKey + '>                ');
      configXML.appendChild(propertyXML2);
      mx.messaging.config.ServerConfig.convertToXML(org.apache.royale.utils.Language.as(propertyValue, mx.messaging.config.ConfigMap), propertyXML2);
    }
  }
};


/**
 * @royaleignorecoercion XML
 * @private
 * @param {XML} destinationConfig
 * @return {Array}
 */
mx.messaging.config.ServerConfig.getChannelIds = function(destinationConfig) {
  var /** @type {Array} */ result = [];
  var /** @type {XMLList} */ channels = destinationConfig.child('channels').child('channel');
  var /** @type {number} */ n = channels.length();
  for (var /** @type {number} */ i = 0; i < n; i++) {
    result.push(channels[i].attribute('ref').toString());
  }
  if (n == 0) {
    channels = destinationConfig.parent().child("default-channels").child('channel');
    n = channels.length();
    for (i = 0; i < n; i++) {
      result.push(channels[i].attribute('ref').toString());
    }
  }
  return result;
};


/**
 * @asprivate
 * This method returns a list of default channel ids for the application
 * @private
 * @return {Array}
 */
mx.messaging.config.ServerConfig.getDefaultChannelIds = function() {
  var /** @type {Array} */ result = [];
  var /** @type {XMLList} */ channels = mx.messaging.config.ServerConfig["xml"].child("default-channels").child('channel');
  var /** @type {number} */ n = channels.length();
  for (var /** @type {number} */ i = 0; i < n; i++) {
    result.push(channels[i].attribute('ref').toString());
  }
  return result;
};


/**
 *  Returns the destination XML data specific to the destination and message
 *  type specified. Returns null if the destination is not found.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @private
 * @param {string} destinationId
 * @return {XML}
 */
mx.messaging.config.ServerConfig.getDestinationConfig = function(destinationId) {
  var /** @type {XMLList} */ destinations = mx.messaging.config.ServerConfig["xml"].descendants('destination').filter(function(/** @type {XML} */ node){return (node.attribute('id') == destinationId)});
  var /** @type {number} */ destinationCount = destinations.length();
  if (destinationCount == 0) {
    return null;
  } else {
    return destinations[0];
  }
};


/**
 *  Helper method to look up and return a cached ChannelSet (and build and
 *  cache an instance if necessary).
 *
 *  @asparam destinationConfig The configuration for the target destination.
 *  @asparam destinatonId The id of the target destination.
 *
 *  @asreturn The ChannelSet.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3 
 * @private
 * @param {XML} destinationConfig
 * @param {string} destinationId
 * @return {mx.messaging.ChannelSet}
 */
mx.messaging.config.ServerConfig.internalGetChannelSet = function(destinationConfig, destinationId) {
  var /** @type {Array} */ channelIds;
  var /** @type {boolean} */ clustered;
  if (destinationConfig == null) {
    channelIds = mx.messaging.config.ServerConfig.getDefaultChannelIds();
    if (channelIds.length == 0) {
      var /** @type {string} */ message = mx.messaging.config.ServerConfig["resourceManager"].getString("messaging", "noChannelForDestination", [destinationId]);
      throw new mx.messaging.errors.InvalidDestinationError(message);
    }
    clustered = false;
  } else {
    channelIds = mx.messaging.config.ServerConfig.getChannelIds(destinationConfig);
    clustered = (destinationConfig.child('properties').child('network').child('cluster').length() > 0) ? true : false;
  }
  var /** @type {string} */ channelSetId = channelIds.join(",") + ":" + clustered;
  if (channelSetId in mx.messaging.config.ServerConfig._channelSets) {
    return mx.messaging.config.ServerConfig._channelSets[channelSetId];
  } else {
    if (mx.messaging.config.ServerConfig.channelSetFactory == null)
      mx.messaging.config.ServerConfig.channelSetFactory = mx.messaging.ChannelSet;
    var /** @type {mx.messaging.ChannelSet} */ channelSet = new mx.messaging.config.ServerConfig.channelSetFactory(channelIds, clustered);
    var /** @type {number} */ heartbeatMillis = (mx.messaging.config.ServerConfig.serverConfigData.child("flex-client").child("heartbeat-interval-millis")) >> 0;
    if (heartbeatMillis > 0)
      channelSet.heartbeatInterval = heartbeatMillis;
    if (clustered)
      channelSet.initialDestinationId = destinationId;
    mx.messaging.config.ServerConfig._channelSets[channelSetId] = channelSet;
    return channelSet;
  }
};


mx.messaging.config.ServerConfig.get__resourceManager = function() {
  if (!mx.messaging.config.ServerConfig._resourceManager)
    mx.messaging.config.ServerConfig._resourceManager = mx.resources.ResourceManager.getInstance();
  return mx.messaging.config.ServerConfig._resourceManager;
};


mx.messaging.config.ServerConfig.get__xml = function() {
  if (mx.messaging.config.ServerConfig.serverConfigData == null)
    mx.messaging.config.ServerConfig.serverConfigData = new XML( '<services/>');
  return mx.messaging.config.ServerConfig.serverConfigData;
};


mx.messaging.config.ServerConfig.set__xml = function(value) {
  mx.messaging.config.ServerConfig.serverConfigData = value;
  mx.messaging.config.ServerConfig._channelSets = {};
  mx.messaging.config.ServerConfig._clusteredChannels = {};
  mx.messaging.config.ServerConfig._unclusteredChannels = {};
};


Object.defineProperties(mx.messaging.config.ServerConfig, /** @lends {mx.messaging.config.ServerConfig} */ {
/**
  * @export
  * @type {mx.resources.IResourceManager} */
resourceManager: {
get: mx.messaging.config.ServerConfig.get__resourceManager},
/**
  * @export
  * @type {XML} */
xml: {
get: mx.messaging.config.ServerConfig.get__xml,
set: mx.messaging.config.ServerConfig.set__xml}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.config.ServerConfig.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'ServerConfig', qName: 'mx.messaging.config.ServerConfig', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.config.ServerConfig.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|serverConfigData': { type: 'XML', get_set: function (/** * */ v) {return v !== undefined ? mx.messaging.config.ServerConfig.serverConfigData = v : mx.messaging.config.ServerConfig.serverConfigData;}},
        '|channelSetFactory': { type: 'Class', get_set: function (/** * */ v) {return v !== undefined ? mx.messaging.config.ServerConfig.channelSetFactory = v : mx.messaging.config.ServerConfig.channelSetFactory;}}
      };
    },
    accessors: function () {
      return {
        '|xml': { type: 'XML', access: 'readwrite', declaredBy: 'mx.messaging.config.ServerConfig'}
      };
    },
    methods: function () {
      return {
        '|checkChannelConsistency': { type: 'void', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'String', false ,'String', false ]; }},
        '|getChannel': { type: 'mx.messaging.Channel', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'String', false ,'Boolean', true ]; }},
        '|getChannelSet': { type: 'mx.messaging.ChannelSet', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'String', false ]; }},
        '|getProperties': { type: 'XMLList', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'String', false ]; }},
        '|http://www.adobe.com/2006/flex/mx/internal::channelSetMatchesDestinationConfig': { type: 'Boolean', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'mx.messaging.ChannelSet', false ,'String', false ]; }},
        '|http://www.adobe.com/2006/flex/mx/internal::fetchedConfig': { type: 'Boolean', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'String', false ]; }},
        '|http://www.adobe.com/2006/flex/mx/internal::getChannelIdList': { type: 'Array', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'String', false ]; }},
        '|http://www.adobe.com/2006/flex/mx/internal::needsConfig': { type: 'Boolean', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'mx.messaging.Channel', false ]; }},
        '|http://www.adobe.com/2006/flex/mx/internal::updateServerConfigData': { type: 'void', declaredBy: 'mx.messaging.config.ServerConfig', parameters: function () { return [ 'mx.messaging.config.ConfigMap', false ,'String', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.config.ServerConfig.prototype.ROYALE_COMPILE_FLAGS = 26;
