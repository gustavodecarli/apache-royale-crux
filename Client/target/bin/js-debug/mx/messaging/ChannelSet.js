/**
 * Generated by Apache Royale Compiler from mx/messaging/ChannelSet.as
 * mx.messaging.ChannelSet
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.messaging.ChannelSet');
/* Royale Dependency List: mx.collections.ArrayCollection,mx.core.mx_internal,mx.errors.IllegalOperationError,mx.events.PropertyChangeEvent,mx.logging.Log,mx.messaging.Channel,mx.messaging.channels.NetConnectionChannel,mx.messaging.channels.PollingChannel,mx.messaging.config.ServerConfig,mx.messaging.errors.NoChannelAvailableError,mx.messaging.events.ChannelEvent,mx.messaging.events.ChannelFaultEvent,mx.messaging.events.MessageEvent,mx.messaging.events.MessageFaultEvent,mx.messaging.messages.AcknowledgeMessage,mx.messaging.messages.CommandMessage,mx.messaging.messages.ErrorMessage,mx.messaging.messages.IMessage,mx.resources.IResourceManager,mx.resources.ResourceManager,mx.rpc.AsyncDispatcher,mx.rpc.AsyncToken,mx.rpc.events.AbstractEvent,mx.rpc.events.FaultEvent,mx.rpc.events.ResultEvent,mx.utils.Base64Encoder,org.apache.royale.events.Event,org.apache.royale.utils.Timer,org.apache.royale.utils.Language,XML*/
goog.provide('mx.messaging.ChannelSet.AuthenticationAgent');
goog.provide('mx.messaging.ChannelSet.ClusterMessageResponder');
goog.provide('mx.messaging.ChannelSet.PendingSend');

goog.require('mx.messaging.MessageAgent');
goog.require('mx.messaging.MessageResponder');
goog.require('org.apache.royale.events.EventDispatcher');



/**
 *  Constructs a ChannelSet.
 *  If the <code>channelIds</code> argument is provided, the ChannelSet will
 *  use automatically configured Channels obtained via <code>ServerConfig.getChannel()</code>
 *  to reach a destination.
 *  Attempting to manually assign Channels to a ChannelSet that uses configured
 *  Channels is not allowed.
 *
 *  <p>If the <code>channelIds</code> argument is not provided or is null,
 *  Channels must be manually created and added to the ChannelSet in order
 *  to connect and send messages.</p>
 *
 *  <p>If the ChannelSet is clustered using url-load-balancing (where each server
 *  declares a unique RTMP or HTTP URL and the client fails over from one URL to
 *  the next), the first time that a Channel in the ChannelSet successfully connects
 *  the ChannelSet will automatically make a request for all of the endpoints across
 *  the cluster for all member Channels and will assign these failover URLs to each
 *  respective Channel.
 *  This allows Channels in the ChannelSet to failover individually, and when failover
 *  options for a specific Channel are exhausted the ChannelSet will advance to the next
 *  Channel in the set to attempt to reconnect.</p>
 *
 *  <p>Regardless of clustering, if a Channel cannot connect or looses
 *  connectivity, the ChannelSet will advance to its next available Channel
 *  and attempt to reconnect.
 *  This allows the ChannelSet to hunt through Channels that use different
 *  protocols, ports, etc., in search of one that can connect to its endpoint
 *  successfully.</p>
 *
 *  @asparam channelIds The ids of configured Channels obtained from ServerConfig for this ChannelSet to
 *                    use. If null, Channels must be manually added to the ChannelSet.
 *
 *  @asparam clusteredWithURLLoadBalancing True if the Channels in the ChannelSet are clustered
 *                   using url load balancing.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @constructor
 * @extends {org.apache.royale.events.EventDispatcher}
 * @param {Array=} channelIds
 * @param {boolean=} clusteredWithURLLoadBalancing
 */
mx.messaging.ChannelSet = function(channelIds, clusteredWithURLLoadBalancing) {
  channelIds = typeof channelIds !== 'undefined' ? channelIds : null;
  clusteredWithURLLoadBalancing = typeof clusteredWithURLLoadBalancing !== 'undefined' ? clusteredWithURLLoadBalancing : false;
  
  this.mx_messaging_ChannelSet_resourceManager = mx.resources.ResourceManager.getInstance();
  mx.messaging.ChannelSet.base(this, 'constructor');
  this.mx_messaging_ChannelSet__clustered = clusteredWithURLLoadBalancing;
  this.mx_messaging_ChannelSet__connected = false;
  this.mx_messaging_ChannelSet__connecting = false;
  this.mx_messaging_ChannelSet__currentChannelIndex = -1;
  if (channelIds != null) {
    this.mx_messaging_ChannelSet__channelIds = channelIds;
    this.mx_messaging_ChannelSet__channels = new Array(this.mx_messaging_ChannelSet__channelIds.length);
    this.mx_messaging_ChannelSet__configured = true;
  } else {
    this.mx_messaging_ChannelSet__channels = [];
    this.mx_messaging_ChannelSet__configured = false;
  }
  this.mx_messaging_ChannelSet__hasRequestedClusterEndpoints = false;
  this.mx_messaging_ChannelSet__hunting = false;
  this.mx_messaging_ChannelSet__messageAgents = [];
  this.mx_messaging_ChannelSet__pendingMessages = {};
  this.mx_messaging_ChannelSet__pendingSends = [];
  this.mx_messaging_ChannelSet__shouldBeConnected = false;
  this.mx_messaging_ChannelSet__shouldHunt = true;
};
goog.inherits(mx.messaging.ChannelSet, org.apache.royale.events.EventDispatcher);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.ChannelSet', mx.messaging.ChannelSet);


/**
 * @private
 * @type {mx.messaging.ChannelSet.AuthenticationAgent}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__authAgent;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__connecting;


/**
 * @private
 * @type {string}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__credentials;


/**
 * @private
 * @type {string}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__credentialsCharset;


/**
 * @private
 * @type {number}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__currentChannelIndex = 0;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__hasRequestedClusterEndpoints;


/**
 * @private
 * @type {org.apache.royale.utils.Timer}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__heartbeatTimer;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__hunting;


/**
 * @private
 * @type {Object}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__pendingMessages;


/**
 * @private
 * @type {Array}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__pendingSends;


/**
 * @private
 * @type {org.apache.royale.utils.Timer}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__reconnectTimer = null;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__shouldBeConnected;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__shouldHunt;


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet_resourceManager;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__authenticated;


/**
 *  @asprivate
 * @export
 * @param {boolean} value
 * @param {string} creds
 * @param {boolean=} notifyAgents
 */
mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated = function(value, creds, notifyAgents) {
  notifyAgents = typeof notifyAgents !== 'undefined' ? notifyAgents : true;
  if (this.mx_messaging_ChannelSet__authenticated != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "authenticated", this.mx_messaging_ChannelSet__authenticated, value);
    this.mx_messaging_ChannelSet__authenticated = value;
    if (notifyAgents) {
      var /** @type {mx.messaging.MessageAgent} */ ma;
      for (var /** @type {number} */ i = 0; i < this.mx_messaging_ChannelSet__messageAgents.length; i++) {
        ma = org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__messageAgents[i], mx.messaging.MessageAgent, true);
        ma.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated(value, creds);
      }
    }
    if (!value && this.mx_messaging_ChannelSet__authAgent != null)
      this.mx_messaging_ChannelSet__authAgent.state = mx.messaging.ChannelSet.AuthenticationAgent.LOGGED_OUT_STATE;
    this.dispatchEvent(event);
  }
};


/**
 * @private
 * @type {Array}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__channels;


/**
 * @private
 * @type {Array}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__channelIds;


/**
 * @private
 * @type {mx.messaging.Channel}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__currentChannel;


/**
 * @private
 * @type {Object}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__channelFailoverURIs;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__configured;


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__connected;


/**
 *  @asprivate
 * @export
 * @param {boolean} value
 */
mx.messaging.ChannelSet.prototype.setConnected = function(value) {
  if (this.mx_messaging_ChannelSet__connected != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "connected", this.mx_messaging_ChannelSet__connected, value);
    this.mx_messaging_ChannelSet__connected = value;
    this.dispatchEvent(event);
    this.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated(!!(value && this.currentChannel && this.currentChannel.authenticated), this.mx_messaging_ChannelSet__credentials, false);
    if (!this.connected) {
      this.unscheduleHeartbeat();
    } else if (this.heartbeatInterval > 0) {
      this.scheduleHeartbeat();
    }
  }
};


/**
 * @private
 * @type {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__clustered;


/**
 * @private
 * @type {number}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__heartbeatInterval = 0;


/**
 * @private
 * @type {string}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__initialDestinationId;


/**
 * @private
 * @type {Array}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet__messageAgents;


/**
 *  Returns a String containing the ids of the Channels in the ChannelSet.
 *
 *  @asreturn String representation of the ChannelSet.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @override
 */
mx.messaging.ChannelSet.prototype.toString = function() {
  var /** @type {string} */ s = "[ChannelSet ";
  for (var /** @type {number} */ i = 0; i < this.mx_messaging_ChannelSet__channels.length; i++) {
    if (this.mx_messaging_ChannelSet__channels[i] != null)
      s += this.mx_messaging_ChannelSet__channels[i].id + " ";
  }
  s += "]";
  return s;
};


/**
 *  Adds a Channel to the ChannelSet. A Channel with a null id cannot be added
 *  to the ChannelSet if the ChannelSet targets a clustered destination.
 *
 *  @asparam channel The Channel to add.
 *
 *  @throws flash.errors.IllegalOperationError If the ChannelSet is
 *             <code>configured</code>, adding a Channel is not supported.
 *             This error is also thrown if the ChannelSet's <code>clustered</code> property
 *             is <code>true</code> but the Channel has a null id.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.Channel} channel
 */
mx.messaging.ChannelSet.prototype.addChannel = function(channel) {
  if (channel == null)
    return;
  var /** @type {string} */ message;
  if (this.http_$$www_adobe_com$2006$flex$mx$internal__configured) {
    message = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "cannotAddWhenConfigured");
    throw new mx.errors.IllegalOperationError(message);
  }
  if (this.clustered && channel.id == null) {
    message = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "cannotAddNullIdChannelWhenClustered");
    throw new mx.errors.IllegalOperationError(message);
  }
  if (this.mx_messaging_ChannelSet__channels.indexOf(channel) != -1)
    return;
  this.mx_messaging_ChannelSet__channels.push(channel);
  if (this.mx_messaging_ChannelSet__credentials)
    channel.setCredentials(this.mx_messaging_ChannelSet__credentials, null, this.mx_messaging_ChannelSet__credentialsCharset);
};


/**
 *  Removes a Channel from the ChannelSet. If the Channel to remove is
 *  currently connected and being used by the ChannelSet, it is
 *  disconnected as well as removed.
 *
 *  @asparam channel The Channel to remove.
 *
 *  @throws flash.errors.IllegalOperationError If the ChannelSet is
 *             <code>configured</code>, removing a Channel is not supported.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.Channel} channel
 */
mx.messaging.ChannelSet.prototype.removeChannel = function(channel) {
  if (this.http_$$www_adobe_com$2006$flex$mx$internal__configured) {
    var /** @type {string} */ message = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "cannotRemoveWhenConfigured");
    throw new mx.errors.IllegalOperationError(message);
  }
  var /** @type {number} */ channelIndex = (this.mx_messaging_ChannelSet__channels.indexOf(channel)) >> 0;
  if (channelIndex > -1) {
    this.mx_messaging_ChannelSet__channels.splice(channelIndex, 1);
    if ((this.mx_messaging_ChannelSet__currentChannel != null) && (this.mx_messaging_ChannelSet__currentChannel == channel)) {
      if (this.connected) {
        this.mx_messaging_ChannelSet__shouldHunt = false;
        this.mx_messaging_ChannelSet_disconnectChannel();
      }
      this.mx_messaging_ChannelSet__currentChannel = null;
      this.mx_messaging_ChannelSet__currentChannelIndex = -1;
    }
  }
};


/**
 *  Connects a MessageAgent to the ChannelSet. Once connected, the agent
 *  can use the ChannelSet to send messages.
 *
 *  @asparam agent The MessageAgent to connect.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.MessageAgent} agent
 */
mx.messaging.ChannelSet.prototype.connect = function(agent) {
  if ((agent != null) && (this.mx_messaging_ChannelSet__messageAgents.indexOf(agent) == -1)) {
    this.mx_messaging_ChannelSet__shouldBeConnected = true;
    this.mx_messaging_ChannelSet__messageAgents.push(agent);
    agent.http_$$www_adobe_com$2006$flex$mx$internal__internalSetChannelSet(this);
    this.addEventListener(mx.messaging.events.ChannelEvent.CONNECT, org.apache.royale.utils.Language.closure(agent.channelConnectHandler, agent, 'channelConnectHandler'));
    this.addEventListener(mx.messaging.events.ChannelEvent.DISCONNECT, org.apache.royale.utils.Language.closure(agent.channelDisconnectHandler, agent, 'channelDisconnectHandler'));
    this.addEventListener(mx.messaging.events.ChannelFaultEvent.FAULT, org.apache.royale.utils.Language.closure(agent.channelFaultHandler, agent, 'channelFaultHandler'));
    if (this.connected && !agent.http_$$www_adobe_com$2006$flex$mx$internal__needsConfig)
      agent.channelConnectHandler(mx.messaging.events.ChannelEvent.createEvent(mx.messaging.events.ChannelEvent.CONNECT, this.mx_messaging_ChannelSet__currentChannel, false, false, this.connected));
  }
};


/**
 *  Disconnects a specific MessageAgent from the ChannelSet. If this is the
 *  last MessageAgent using the ChannelSet and the current Channel in the set is
 *  connected, the Channel will physically disconnect from the server.
 *
 *  @asparam agent The MessageAgent to disconnect.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.MessageAgent} agent
 */
mx.messaging.ChannelSet.prototype.disconnect = function(agent) {
  if (agent == null) {
    var /** @type {Array} */ allMessageAgents = this.mx_messaging_ChannelSet__messageAgents.slice();
    var /** @type {number} */ n = (allMessageAgents.length) >> 0;
    for (var /** @type {number} */ i = 0; i < n; i++) {
      allMessageAgents[i].disconnect();
    }
    if (this.mx_messaging_ChannelSet__authAgent != null) {
      this.mx_messaging_ChannelSet__authAgent.state = mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE;
      this.mx_messaging_ChannelSet__authAgent = null;
    }
  } else {
    var /** @type {number} */ agentIndex = (agent != null ? this.mx_messaging_ChannelSet__messageAgents.indexOf(agent) : -1) >> 0;
    if (agentIndex != -1) {
      this.mx_messaging_ChannelSet__messageAgents.splice(agentIndex, 1);
      this.removeEventListener(mx.messaging.events.ChannelEvent.CONNECT, org.apache.royale.utils.Language.closure(agent.channelConnectHandler, agent, 'channelConnectHandler'));
      this.removeEventListener(mx.messaging.events.ChannelEvent.DISCONNECT, org.apache.royale.utils.Language.closure(agent.channelDisconnectHandler, agent, 'channelDisconnectHandler'));
      this.removeEventListener(mx.messaging.events.ChannelFaultEvent.FAULT, org.apache.royale.utils.Language.closure(agent.channelFaultHandler, agent, 'channelFaultHandler'));
      if (this.connected || this.mx_messaging_ChannelSet__connecting) {
        agent.channelDisconnectHandler(mx.messaging.events.ChannelEvent.createEvent(mx.messaging.events.ChannelEvent.DISCONNECT, this.mx_messaging_ChannelSet__currentChannel, false));
      } else {
        var /** @type {number} */ n2 = (this.mx_messaging_ChannelSet__pendingSends.length) >> 0;
        for (var /** @type {number} */ j = 0; j < n2; j++) {
          var /** @type {mx.messaging.ChannelSet.PendingSend} */ ps = org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__pendingSends[j], mx.messaging.ChannelSet.PendingSend, true);
          if (ps.agent == agent) {
            this.mx_messaging_ChannelSet__pendingSends.splice(j, 1);
            j--;
            n2--;
            delete this.mx_messaging_ChannelSet__pendingMessages[ps.message];
          }
        }
      }
      if (this.mx_messaging_ChannelSet__messageAgents.length == 0) {
        this.mx_messaging_ChannelSet__shouldBeConnected = false;
        this.mx_messaging_ChannelSet__currentChannelIndex = -1;
        if (this.connected)
          this.mx_messaging_ChannelSet_disconnectChannel();
      }
      if (agent.http_$$www_adobe_com$2006$flex$mx$internal__channelSetMode == mx.messaging.MessageAgent.http_$$www_adobe_com$2006$flex$mx$internal__AUTO_CONFIGURED_CHANNELSET)
        agent.http_$$www_adobe_com$2006$flex$mx$internal__internalSetChannelSet(null);
    }
  }
};


/**
 *  Disconnects all associated MessageAgents and disconnects any underlying Channel that
 *  is connected.
 *  Unlike <code>disconnect(MessageAgent)</code> which is invoked by the disconnect implementations
 *  of specific service components, this method provides a single, convenient point to shut down
 *  connectivity between the client and server.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 */
mx.messaging.ChannelSet.prototype.disconnectAll = function() {
  this.disconnect(null);
};


/**
 *  Handles a CONNECT ChannelEvent and redispatches the event.
 *
 *  @asparam event The ChannelEvent.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.events.ChannelEvent} event
 */
mx.messaging.ChannelSet.prototype.channelConnectHandler = function(event) {
  this.mx_messaging_ChannelSet__connecting = false;
  this.mx_messaging_ChannelSet__connected = true;
  this.mx_messaging_ChannelSet__currentChannelIndex = -1;
  while (this.mx_messaging_ChannelSet__pendingSends.length > 0) {
    var /** @type {mx.messaging.ChannelSet.PendingSend} */ ps = org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__pendingSends.shift(), mx.messaging.ChannelSet.PendingSend, true);
    delete this.mx_messaging_ChannelSet__pendingMessages[ps.message];
    var /** @type {mx.messaging.messages.CommandMessage} */ command = org.apache.royale.utils.Language.as(ps.message, mx.messaging.messages.CommandMessage);
    if (command != null) {
      if (command.operation == mx.messaging.messages.CommandMessage.TRIGGER_CONNECT_OPERATION) {
        var /** @type {mx.messaging.messages.AcknowledgeMessage} */ ack = new mx.messaging.messages.AcknowledgeMessage();
        ack.clientId = ps.agent.clientId;
        ack.correlationId = command.messageId;
        ps.agent.acknowledge(ack, command);
        continue;
      }
      if (!ps.agent.http_$$www_adobe_com$2006$flex$mx$internal__configRequested && ps.agent.http_$$www_adobe_com$2006$flex$mx$internal__needsConfig && (command.operation == mx.messaging.messages.CommandMessage.CLIENT_PING_OPERATION)) {
        command.headers[mx.messaging.messages.CommandMessage.NEEDS_CONFIG_HEADER] = true;
        ps.agent.http_$$www_adobe_com$2006$flex$mx$internal__configRequested = true;
      }
    }
    this.send(ps.agent, ps.message);
  }
  if (this.mx_messaging_ChannelSet__hunting) {
    event.reconnecting = true;
    this.mx_messaging_ChannelSet__hunting = false;
  }
  this.dispatchEvent(event);
  var /** @type {mx.events.PropertyChangeEvent} */ connectedChangeEvent = mx.events.PropertyChangeEvent.createUpdateEvent(this, "connected", false, true);
  this.dispatchEvent(connectedChangeEvent);
};


/**
 *  Handles a DISCONNECT ChannelEvent and redispatches the event.
 *
 *  @asparam event The ChannelEvent.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.events.ChannelEvent} event
 */
mx.messaging.ChannelSet.prototype.channelDisconnectHandler = function(event) {
  this.mx_messaging_ChannelSet__connecting = false;
  this.setConnected(false);
  if (this.mx_messaging_ChannelSet__shouldBeConnected && !event.reconnecting && !event.rejected) {
    if (this.mx_messaging_ChannelSet__shouldHunt && this.mx_messaging_ChannelSet_hunt()) {
      event.reconnecting = true;
      this.dispatchEvent(event);
      if (org.apache.royale.utils.Language.is(this.mx_messaging_ChannelSet__currentChannel, mx.messaging.channels.NetConnectionChannel)) {
        if (this.mx_messaging_ChannelSet__reconnectTimer == null) {
          this.mx_messaging_ChannelSet__reconnectTimer = new org.apache.royale.utils.Timer(1, 1);
          this.mx_messaging_ChannelSet__reconnectTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.mx_messaging_ChannelSet_reconnectChannel, this, 'reconnectChannel'));
          this.mx_messaging_ChannelSet__reconnectTimer.start();
        }
      } else {
        this.mx_messaging_ChannelSet_connectChannel();
      }
    } else {
      this.dispatchEvent(event);
      this.faultPendingSends(event);
    }
  } else {
    this.dispatchEvent(event);
    if (event.rejected)
      this.faultPendingSends(event);
  }
  this.mx_messaging_ChannelSet__shouldHunt = true;
};


/**
 *  Handles a ChannelFaultEvent and redispatches the event.
 *
 *  @asparam event The ChannelFaultEvent.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.events.ChannelFaultEvent} event
 */
mx.messaging.ChannelSet.prototype.channelFaultHandler = function(event) {
  if (event.channel.connected) {
    this.dispatchEvent(event);
  } else {
    this.mx_messaging_ChannelSet__connecting = false;
    this.setConnected(false);
    if (this.mx_messaging_ChannelSet__shouldBeConnected && !event.reconnecting && !event.rejected) {
      if (this.mx_messaging_ChannelSet_hunt()) {
        event.reconnecting = true;
        this.dispatchEvent(event);
        if (org.apache.royale.utils.Language.is(this.mx_messaging_ChannelSet__currentChannel, mx.messaging.channels.NetConnectionChannel)) {
          if (this.mx_messaging_ChannelSet__reconnectTimer == null) {
            this.mx_messaging_ChannelSet__reconnectTimer = new org.apache.royale.utils.Timer(1, 1);
            this.mx_messaging_ChannelSet__reconnectTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.mx_messaging_ChannelSet_reconnectChannel, this, 'reconnectChannel'));
            this.mx_messaging_ChannelSet__reconnectTimer.start();
          }
        } else {
          this.mx_messaging_ChannelSet_connectChannel();
        }
      } else {
        this.dispatchEvent(event);
        this.faultPendingSends(event);
      }
    } else {
      this.dispatchEvent(event);
      if (event.rejected)
        this.faultPendingSends(event);
    }
  }
};


/**
 *  Authenticates the ChannelSet with the server using the provided credentials.
 *  Unlike other operations on Channels and the ChannelSet, this operation returns an
 *  AsyncToken that client code may add a responder to in order to handle success or
 *  failure directly.
 *  If the ChannelSet is not connected to the server when this method is invoked it will
 *  trigger a connect attempt, and if successful, send the login command to the server.
 *  Only one login or logout operation may be pending at a time and overlapping calls will
 *  generate an IllegalOperationError.
 *  Invoking login when the ChannelSet is already authenticated will generate also generate
 *  an IllegalOperationError.
 *
 *  @asparam username The username.
 *  @asparam password The password.
 *  @asparam charset The character set encoding to use while encoding the
 *  credentials. The default is null, which implies the legacy charset of
 *  ISO-Latin-1. The only other supported charset is &quot;UTF-8&quot;.
 *
 *  @asreturn Returns a token that client code may add a responder to in order to handle
 *  success or failure directly.
 *
 *  @throws flash.errors.IllegalOperationError in two situations; if the ChannelSet is
 *          already authenticated, or if a login or logout operation is currently in progress.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {string} username
 * @param {string} password
 * @param {string=} charset
 * @return {mx.rpc.AsyncToken}
 */
mx.messaging.ChannelSet.prototype.login = function(username, password, charset) {
  charset = typeof charset !== 'undefined' ? charset : null;
  if (this.authenticated)
    throw new mx.errors.IllegalOperationError("ChannelSet is already authenticated.");
  if ((this.mx_messaging_ChannelSet__authAgent != null) && (this.mx_messaging_ChannelSet__authAgent.state != mx.messaging.ChannelSet.AuthenticationAgent.LOGGED_OUT_STATE))
    throw new mx.errors.IllegalOperationError("ChannelSet is in the process of logging in or logging out.");
  if (charset != mx.utils.Base64Encoder.CHARSET_UTF_8)
    charset = null;
  var /** @type {string} */ credentials = null;
  if (username != null && password != null) {
    var /** @type {string} */ rawCredentials = username + ":" + password;
    var /** @type {mx.utils.Base64Encoder} */ encoder = new mx.utils.Base64Encoder();
    if (charset == mx.utils.Base64Encoder.CHARSET_UTF_8)
      encoder.encodeUTFBytes(rawCredentials);
    else
      encoder.encode(rawCredentials);
    credentials = encoder.drain();
  }
  var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
  msg.operation = mx.messaging.messages.CommandMessage.LOGIN_OPERATION;
  msg.body = credentials;
  if (charset != null)
    msg.headers[mx.messaging.messages.CommandMessage.CREDENTIALS_CHARSET_HEADER] = charset;
  msg.destination = "auth";
  var /** @type {mx.rpc.AsyncToken} */ token = new mx.rpc.AsyncToken(msg);
  if (this.mx_messaging_ChannelSet__authAgent == null)
    this.mx_messaging_ChannelSet__authAgent = new mx.messaging.ChannelSet.AuthenticationAgent(this);
  this.mx_messaging_ChannelSet__authAgent.registerToken(token);
  this.mx_messaging_ChannelSet__authAgent.state = mx.messaging.ChannelSet.AuthenticationAgent.LOGGING_IN_STATE;
  this.send(this.mx_messaging_ChannelSet__authAgent, msg);
  return token;
};


/**
 *  Logs the ChannelSet out from the server. Unlike other operations on Channels
 *  and the ChannelSet, this operation returns an AsyncToken that client code may
 *  add a responder to in order to handle success or failure directly.
 *  If logout is successful any credentials that have been cached for use in
 *  automatic reconnects are cleared for the ChannelSet and its Channels and their
 *  authenticated state is set to false.
 *  If the ChannelSet is not connected to the server when this method is invoked it
 *  will trigger a connect attempt, and if successful, send a logout command to the server.
 *
 *  <p>The MessageAgent argument is present to support legacy logout behavior and client code that
 *  invokes this method should not pass a MessageAgent reference. Just invoke <code>logout()</code>
 *  passing no arguments.</p>
 *
 *  <p>This method is also invoked by service components from their <code>logout()</code>
 *  methods, and these components pass a MessageAgent reference to this method when they logout.
 *  The presence of this argument is the trigger to execute legacy logout behavior that differs
 *  from the new behavior described above.
 *  Legacy behavior only sends a logout request to the server if the client is connected
 *  and authenticated.
 *  If these conditions are not met the legacy behavior for this method is to do nothing other
 *  than clear any credentials that have been cached for use in automatic reconnects.</p>
 *
 *  @asparam agent Legacy argument. The MessageAgent that is initiating the logout.
 *
 *  @asreturn Returns a token that client code may
 *  add a responder to in order to handle success or failure directly.
 *
 *  @throws flash.errors.IllegalOperationError if a login or logout operation is currently in progress.
 * @export
 * @param {mx.messaging.MessageAgent=} agent
 * @return {mx.rpc.AsyncToken}
 */
mx.messaging.ChannelSet.prototype.logout = function(agent) {
  agent = typeof agent !== 'undefined' ? agent : null;
  this.mx_messaging_ChannelSet__credentials = null;
  if (agent == null) {
    if ((this.mx_messaging_ChannelSet__authAgent != null) && (this.mx_messaging_ChannelSet__authAgent.state == mx.messaging.ChannelSet.AuthenticationAgent.LOGGING_OUT_STATE || this.mx_messaging_ChannelSet__authAgent.state == mx.messaging.ChannelSet.AuthenticationAgent.LOGGING_IN_STATE))
      throw new mx.errors.IllegalOperationError("ChannelSet is in the process of logging in or logging out.");
    var /** @type {number} */ n = (this.mx_messaging_ChannelSet__messageAgents.length) >> 0;
    var /** @type {number} */ i = 0;
    for (; i < n; i++) {
      org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__messageAgents[i], mx.messaging.MessageAgent, true).http_$$www_adobe_com$2006$flex$mx$internal__internalSetCredentials(null);
    }
    n = (this.mx_messaging_ChannelSet__channels.length) >> 0;
    for (i = 0; i < n; i++) {
      if (this.mx_messaging_ChannelSet__channels[i] != null) {
        org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__channels[i], mx.messaging.Channel, true).http_$$www_adobe_com$2006$flex$mx$internal__internalSetCredentials(null);
        if (org.apache.royale.utils.Language.is(this.mx_messaging_ChannelSet__channels[i], mx.messaging.channels.PollingChannel))
          org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__channels[i], mx.messaging.channels.PollingChannel, true).disablePolling();
      }
    }
    var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
    msg.operation = mx.messaging.messages.CommandMessage.LOGOUT_OPERATION;
    msg.destination = "auth";
    var /** @type {mx.rpc.AsyncToken} */ token = new mx.rpc.AsyncToken(msg);
    if (this.mx_messaging_ChannelSet__authAgent == null)
      this.mx_messaging_ChannelSet__authAgent = new mx.messaging.ChannelSet.AuthenticationAgent(this);
    this.mx_messaging_ChannelSet__authAgent.registerToken(token);
    this.mx_messaging_ChannelSet__authAgent.state = mx.messaging.ChannelSet.AuthenticationAgent.LOGGING_OUT_STATE;
    this.send(this.mx_messaging_ChannelSet__authAgent, msg);
    return token;
  } else {
    var /** @type {number} */ n2 = (this.mx_messaging_ChannelSet__channels.length) >> 0;
    for (var /** @type {number} */ i2 = 0; i2 < n2; i2++) {
      if (this.mx_messaging_ChannelSet__channels[i2] != null)
        this.mx_messaging_ChannelSet__channels[i2].logout(agent);
    }
    return null;
  }
};


/**
 *  Sends a message from a MessageAgent over the currently connected Channel.
 *
 *  @asparam agent The MessageAgent sending the message.
 *
 *  @asparam message The Message to send.
 *
 *  @throws mx.messaging.errors.NoChannelAvailableError If the ChannelSet has no internal
 *                                  Channels to use.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.messaging.MessageAgent} agent
 * @param {mx.messaging.messages.IMessage} message
 */
mx.messaging.ChannelSet.prototype.send = function(agent, message) {
  if (this.mx_messaging_ChannelSet__currentChannel != null && this.mx_messaging_ChannelSet__currentChannel.connected) {
    if ((org.apache.royale.utils.Language.is(message, mx.messaging.messages.CommandMessage) && org.apache.royale.utils.Language.as(message, mx.messaging.messages.CommandMessage, true).operation == mx.messaging.messages.CommandMessage.TRIGGER_CONNECT_OPERATION) && !agent.http_$$www_adobe_com$2006$flex$mx$internal__needsConfig) {
      var /** @type {mx.messaging.messages.AcknowledgeMessage} */ ack = new mx.messaging.messages.AcknowledgeMessage();
      ack.clientId = agent.clientId;
      ack.correlationId = message.messageId;
      new mx.rpc.AsyncDispatcher(org.apache.royale.utils.Language.closure(agent.acknowledge, agent, 'acknowledge'), [ack, message], 1);
      return;
    }
    if (!this.mx_messaging_ChannelSet__hasRequestedClusterEndpoints && this.clustered) {
      var /** @type {mx.messaging.messages.CommandMessage} */ msg = new mx.messaging.messages.CommandMessage();
      if (org.apache.royale.utils.Language.is(agent, mx.messaging.ChannelSet.AuthenticationAgent)) {
        msg.destination = this.initialDestinationId;
      } else {
        msg.destination = agent.destination;
      }
      msg.operation = mx.messaging.messages.CommandMessage.CLUSTER_REQUEST_OPERATION;
      this.mx_messaging_ChannelSet__currentChannel.http_$$www_adobe_com$2006$flex$mx$internal__sendInternalMessage(new mx.messaging.ChannelSet.ClusterMessageResponder(msg, this));
      this.mx_messaging_ChannelSet__hasRequestedClusterEndpoints = true;
    }
    this.unscheduleHeartbeat();
    this.mx_messaging_ChannelSet__currentChannel.send(agent, message);
    this.scheduleHeartbeat();
  } else {
    if (this.mx_messaging_ChannelSet__pendingMessages[message] == null) {
      this.mx_messaging_ChannelSet__pendingMessages[message] = true;
      this.mx_messaging_ChannelSet__pendingSends.push(new mx.messaging.ChannelSet.PendingSend(agent, message));
    }
    if (!this.mx_messaging_ChannelSet__connecting) {
      if ((this.mx_messaging_ChannelSet__currentChannel == null) || (this.mx_messaging_ChannelSet__currentChannelIndex == -1))
        this.mx_messaging_ChannelSet_hunt();
      if (org.apache.royale.utils.Language.is(this.mx_messaging_ChannelSet__currentChannel, mx.messaging.channels.NetConnectionChannel)) {
        if (this.mx_messaging_ChannelSet__reconnectTimer == null) {
          this.mx_messaging_ChannelSet__reconnectTimer = new org.apache.royale.utils.Timer(1, 1);
          this.mx_messaging_ChannelSet__reconnectTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.mx_messaging_ChannelSet_reconnectChannel, this, 'reconnectChannel'));
          this.mx_messaging_ChannelSet__reconnectTimer.start();
        }
      } else {
        this.mx_messaging_ChannelSet_connectChannel();
      }
    }
  }
};


/**
 *  Stores the credentials and passes them through to every connected channel.
 *
 *  @asparam credentials The credentials for the MessageAgent.
 *  @asparam agent The MessageAgent that is setting the credentials.
 *  @asparam charset The character set encoding used while encoding the
 *  credentials. The default is null, which implies the legacy encoding of
 *  ISO-Latin-1.
 *
 *  @throws flash.errors.IllegalOperationError in two situations; if credentials
 *  have already been set and an authentication is in progress with the remote
 *  detination, or if authenticated and the credentials specified don't match
 *  the currently authenticated credentials.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {string} credentials
 * @param {mx.messaging.MessageAgent} agent
 * @param {string=} charset
 */
mx.messaging.ChannelSet.prototype.setCredentials = function(credentials, agent, charset) {
  charset = typeof charset !== 'undefined' ? charset : null;
  this.mx_messaging_ChannelSet__credentials = credentials;
  var /** @type {number} */ n = (this.mx_messaging_ChannelSet__channels.length) >> 0;
  for (var /** @type {number} */ i = 0; i < n; i++) {
    if (this.mx_messaging_ChannelSet__channels[i] != null)
      this.mx_messaging_ChannelSet__channels[i].setCredentials(this.mx_messaging_ChannelSet__credentials, agent, charset);
  }
};


/**
 *  @asprivate
 *  Handles a successful login or logout operation for the ChannelSet.
 * @export
 * @param {mx.messaging.ChannelSet.AuthenticationAgent} agent
 * @param {mx.rpc.AsyncToken} token
 * @param {mx.messaging.messages.AcknowledgeMessage} ackMessage
 */
mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__authenticationSuccess = function(agent, token, ackMessage) {
  var /** @type {mx.messaging.messages.CommandMessage} */ command = org.apache.royale.utils.Language.as(token.message, mx.messaging.messages.CommandMessage, true);
  var /** @type {boolean} */ handlingLogin = (command.operation == mx.messaging.messages.CommandMessage.LOGIN_OPERATION);
  var /** @type {string} */ creds = org.apache.royale.utils.Language.string(handlingLogin ? String(command.body) : null);
  var /** @type {number} */ delay = 0;
  if (handlingLogin) {
    this.mx_messaging_ChannelSet__credentials = creds;
    var /** @type {number} */ n = (this.mx_messaging_ChannelSet__messageAgents.length) >> 0;
    var /** @type {number} */ i = 0;
    for (; i < n; i++) {
      org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__messageAgents[i], mx.messaging.MessageAgent, true).http_$$www_adobe_com$2006$flex$mx$internal__internalSetCredentials(creds);
    }
    n = (this.mx_messaging_ChannelSet__channels.length) >> 0;
    for (i = 0; i < n; i++) {
      if (this.mx_messaging_ChannelSet__channels[i] != null)
        org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__channels[i], mx.messaging.Channel, true).http_$$www_adobe_com$2006$flex$mx$internal__internalSetCredentials(creds);
    }
    agent.state = mx.messaging.ChannelSet.AuthenticationAgent.LOGGED_IN_STATE;
    this.currentChannel.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated(true);
  } else {
    agent.state = mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE;
    this.mx_messaging_ChannelSet__authAgent = null;
    delay = 250;
    this.disconnect(agent);
    this.currentChannel.http_$$www_adobe_com$2006$flex$mx$internal__setAuthenticated(false);
  }
  var /** @type {mx.rpc.events.ResultEvent} */ resultEvent = mx.rpc.events.ResultEvent.createEvent(ackMessage.body, token, ackMessage);
  if (delay > 0)
    new mx.rpc.AsyncDispatcher(org.apache.royale.utils.Language.closure(this.mx_messaging_ChannelSet_dispatchRPCEvent, this, 'dispatchRPCEvent'), [resultEvent], delay);
  else
    this.mx_messaging_ChannelSet_dispatchRPCEvent(resultEvent);
};


/**
 *  @asprivate
 *  Handles a failed login or logout operation for the ChannelSet.
 * @export
 * @param {mx.messaging.ChannelSet.AuthenticationAgent} agent
 * @param {mx.rpc.AsyncToken} token
 * @param {mx.messaging.messages.ErrorMessage} faultMessage
 */
mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__authenticationFailure = function(agent, token, faultMessage) {
  var /** @type {mx.messaging.events.MessageFaultEvent} */ messageFaultEvent = mx.messaging.events.MessageFaultEvent.createEvent(faultMessage);
  var /** @type {mx.rpc.events.FaultEvent} */ faultEvent = mx.rpc.events.FaultEvent.createEventFromMessageFault(messageFaultEvent, token);
  agent.state = mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE;
  this.mx_messaging_ChannelSet__authAgent = null;
  this.disconnect(agent);
  this.mx_messaging_ChannelSet_dispatchRPCEvent(faultEvent);
};


/**
 *  @asprivate
 *  Helper method to fault pending messages.
 *  The ErrorMessage is tagged with a __retryable__ header to indicate that
 *  the error was due to connectivity problems on the client as opposed to
 *  a server error response and the message can be retried (resent).
 *
 *  @asparam event A ChannelEvent.DISCONNECT or a ChannelFaultEvent that is the root cause
 *               for faulting these pending sends.
 * @export
 * @param {mx.messaging.events.ChannelEvent} event
 */
mx.messaging.ChannelSet.prototype.faultPendingSends = function(event) {
  while (this.mx_messaging_ChannelSet__pendingSends.length > 0) {
    var /** @type {mx.messaging.ChannelSet.PendingSend} */ ps = org.apache.royale.utils.Language.as(this.mx_messaging_ChannelSet__pendingSends.shift(), mx.messaging.ChannelSet.PendingSend);
    var /** @type {mx.messaging.messages.IMessage} */ pendingMsg = ps.message;
    delete this.mx_messaging_ChannelSet__pendingMessages[pendingMsg];
    var /** @type {mx.messaging.messages.ErrorMessage} */ errorMsg = new mx.messaging.messages.ErrorMessage();
    errorMsg.correlationId = pendingMsg.messageId;
    errorMsg.headers[mx.messaging.messages.ErrorMessage.RETRYABLE_HINT_HEADER] = true;
    errorMsg.faultCode = "Client.Error.MessageSend";
    errorMsg.faultString = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "sendFailed");
    if (org.apache.royale.utils.Language.is(event, mx.messaging.events.ChannelFaultEvent)) {
      var /** @type {mx.messaging.events.ChannelFaultEvent} */ faultEvent = org.apache.royale.utils.Language.as(event, mx.messaging.events.ChannelFaultEvent);
      errorMsg.faultDetail = faultEvent.faultCode + " " + faultEvent.faultString + " " + faultEvent.faultDetail;
      if (faultEvent.faultCode == "Channel.Authentication.Error")
        errorMsg.faultCode = faultEvent.faultCode;
    } else {
      errorMsg.faultDetail = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "cannotConnectToDestination");
    }
    errorMsg.rootCause = event;
    ps.agent.fault(errorMsg, pendingMsg);
  }
};


/**
 *  Redispatches message events from the currently connected Channel.
 *
 *  @asparam event The MessageEvent from the Channel.
 * @export
 * @param {mx.messaging.events.MessageEvent} event
 */
mx.messaging.ChannelSet.prototype.messageHandler = function(event) {
  this.dispatchEvent(event);
};


/**
 *  @asprivate
 *  Schedules a heartbeat to be sent in heartbeatInterval milliseconds.
 * @export
 */
mx.messaging.ChannelSet.prototype.scheduleHeartbeat = function() {
  if (this.mx_messaging_ChannelSet__heartbeatTimer == null && this.heartbeatInterval > 0) {
    this.mx_messaging_ChannelSet__heartbeatTimer = new org.apache.royale.utils.Timer(this.heartbeatInterval, 1);
    this.mx_messaging_ChannelSet__heartbeatTimer.addEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.sendHeartbeatHandler, this, 'sendHeartbeatHandler'));
    this.mx_messaging_ChannelSet__heartbeatTimer.start();
  }
};


/**
 *  @asprivate
 *  Handles a heartbeat timer event by conditionally sending a heartbeat
 *  and scheduling the next.
 * @export
 * @param {org.apache.royale.events.Event} event
 */
mx.messaging.ChannelSet.prototype.sendHeartbeatHandler = function(event) {
  this.unscheduleHeartbeat();
  if (this.currentChannel != null) {
    this.sendHeartbeat();
    this.scheduleHeartbeat();
  }
};


/**
 *  @asprivate
 *  Sends a heartbeat request.
 * @export
 */
mx.messaging.ChannelSet.prototype.sendHeartbeat = function() {
  var /** @type {mx.messaging.channels.PollingChannel} */ pollingChannel = org.apache.royale.utils.Language.as(this.currentChannel, mx.messaging.channels.PollingChannel);
  if (pollingChannel != null && pollingChannel.http_$$www_adobe_com$2006$flex$mx$internal___shouldPoll)
    return;
  var /** @type {mx.messaging.messages.CommandMessage} */ heartbeat = new mx.messaging.messages.CommandMessage();
  heartbeat.operation = mx.messaging.messages.CommandMessage.CLIENT_PING_OPERATION;
  heartbeat.headers[mx.messaging.messages.CommandMessage.HEARTBEAT_HEADER] = true;
  this.currentChannel.http_$$www_adobe_com$2006$flex$mx$internal__sendInternalMessage(new mx.messaging.MessageResponder(null, heartbeat));
};


/**
 *  @asprivate
 *  Unschedules any currently scheduled pending heartbeat.
 * @export
 */
mx.messaging.ChannelSet.prototype.unscheduleHeartbeat = function() {
  if (this.mx_messaging_ChannelSet__heartbeatTimer != null) {
    this.mx_messaging_ChannelSet__heartbeatTimer.stop();
    this.mx_messaging_ChannelSet__heartbeatTimer.removeEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.sendHeartbeatHandler, this, 'sendHeartbeatHandler'));
    this.mx_messaging_ChannelSet__heartbeatTimer = null;
  }
};


/**
 *  @asprivate
 *  Helper method to connect the current internal Channel.
 * @private
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet_connectChannel = function() {
  this.mx_messaging_ChannelSet__connecting = true;
  this.mx_messaging_ChannelSet__currentChannel.connect(this);
  this.mx_messaging_ChannelSet__currentChannel.addEventListener(mx.messaging.events.MessageEvent.MESSAGE, org.apache.royale.utils.Language.closure(this.messageHandler, this, 'messageHandler'));
};


/**
 *  @asprivate
 *  Helper method to disconnect the current internal Channel.
 * @private
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet_disconnectChannel = function() {
  this.mx_messaging_ChannelSet__connecting = false;
  this.mx_messaging_ChannelSet__currentChannel.removeEventListener(mx.messaging.events.MessageEvent.MESSAGE, org.apache.royale.utils.Language.closure(this.messageHandler, this, 'messageHandler'));
  this.mx_messaging_ChannelSet__currentChannel.disconnect(this);
};


/**
 *  @asprivate
 *  Helper method to dispatch authentication-related RPC events.
 *
 *  @asparam event The event to dispatch.
 * @private
 * @param {mx.rpc.events.AbstractEvent} event
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet_dispatchRPCEvent = function(event) {
  event.http_$$www_adobe_com$2006$flex$mx$internal__callTokenResponders();
  this.dispatchEvent(event);
};


/**
 *  @asprivate
 *  Helper method to hunt to the next available internal Channel for the
 *  ChannelSet.
 *
 *  @asreturn True if hunting to the next available Channel was successful; false if hunting
 *          exhausted available channels and has reset to the beginning of the set.
 *
 *  @throws mx.messaging.errors.NoChannelAvailableError If the ChannelSet has no internal
 *                                  Channels to use.
 * @private
 * @return {boolean}
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet_hunt = function() {
  if (this.mx_messaging_ChannelSet__channels.length == 0) {
    var /** @type {string} */ message = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "noAvailableChannels");
    throw new mx.messaging.errors.NoChannelAvailableError(message);
  }
  if (this.mx_messaging_ChannelSet__currentChannel != null)
    this.mx_messaging_ChannelSet_disconnectChannel();
  if (++this.mx_messaging_ChannelSet__currentChannelIndex >= this.mx_messaging_ChannelSet__channels.length) {
    this.mx_messaging_ChannelSet__currentChannelIndex = -1;
    return false;
  }
  if (this.mx_messaging_ChannelSet__currentChannelIndex > 0)
    this.mx_messaging_ChannelSet__hunting = true;
  if (this.http_$$www_adobe_com$2006$flex$mx$internal__configured) {
    if (this.mx_messaging_ChannelSet__channels[this.mx_messaging_ChannelSet__currentChannelIndex] != null) {
      this.mx_messaging_ChannelSet__currentChannel = this.mx_messaging_ChannelSet__channels[this.mx_messaging_ChannelSet__currentChannelIndex];
    } else {
      this.mx_messaging_ChannelSet__currentChannel = mx.messaging.config.ServerConfig.getChannel(org.apache.royale.utils.Language.string(this.mx_messaging_ChannelSet__channelIds[this.mx_messaging_ChannelSet__currentChannelIndex]), this.mx_messaging_ChannelSet__clustered);
      this.mx_messaging_ChannelSet__currentChannel.setCredentials(this.mx_messaging_ChannelSet__credentials);
      this.mx_messaging_ChannelSet__channels[this.mx_messaging_ChannelSet__currentChannelIndex] = this.mx_messaging_ChannelSet__currentChannel;
    }
  } else {
    this.mx_messaging_ChannelSet__currentChannel = this.mx_messaging_ChannelSet__channels[this.mx_messaging_ChannelSet__currentChannelIndex];
  }
  if ((this.mx_messaging_ChannelSet__channelFailoverURIs != null) && (this.mx_messaging_ChannelSet__channelFailoverURIs[this.mx_messaging_ChannelSet__currentChannel.id] != null))
    this.mx_messaging_ChannelSet__currentChannel.failoverURIs = this.mx_messaging_ChannelSet__channelFailoverURIs[this.mx_messaging_ChannelSet__currentChannel.id];
  return true;
};


/**
 *  @asprivate
 *  This method is invoked by a timer and it works around a reconnect issue
 *  with NetConnection based channels within a single frame by reconnecting after a slight delay.
 * @private
 * @param {org.apache.royale.events.Event} event
 */
mx.messaging.ChannelSet.prototype.mx_messaging_ChannelSet_reconnectChannel = function(event) {
  this.mx_messaging_ChannelSet__reconnectTimer.stop();
  this.mx_messaging_ChannelSet__reconnectTimer.removeEventListener(org.apache.royale.utils.Timer.TIMER, org.apache.royale.utils.Language.closure(this.mx_messaging_ChannelSet_reconnectChannel, this, 'reconnectChannel'));
  this.mx_messaging_ChannelSet__reconnectTimer = null;
  this.mx_messaging_ChannelSet_connectChannel();
};


mx.messaging.ChannelSet.prototype.get__authenticated = function() {
  return this.mx_messaging_ChannelSet__authenticated;
};


mx.messaging.ChannelSet.prototype.get__channels = function() {
  return this.mx_messaging_ChannelSet__channels;
};


mx.messaging.ChannelSet.prototype.set__channels = function(values) {
  if (this.http_$$www_adobe_com$2006$flex$mx$internal__configured) {
    var /** @type {string} */ message = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "cannotAddWhenConfigured");
    throw new mx.errors.IllegalOperationError(message);
  }
  var /** @type {Array} */ channelsToRemove = this.mx_messaging_ChannelSet__channels.slice();
  var /** @type {number} */ n = (channelsToRemove.length) >> 0;
  for (var /** @type {number} */ i = 0; i < n; i++) {
    this.removeChannel(channelsToRemove[i]);
  }
  if (values != null && values.length > 0) {
    var /** @type {number} */ m = (values.length) >> 0;
    for (var /** @type {number} */ j = 0; j < m; j++) {
      this.addChannel(values[j]);
    }
  }
};


mx.messaging.ChannelSet.prototype.get__channelIds = function() {
  if (this.mx_messaging_ChannelSet__channelIds != null) {
    return this.mx_messaging_ChannelSet__channelIds;
  } else {
    var /** @type {Array} */ ids = [];
    var /** @type {number} */ n = (this.mx_messaging_ChannelSet__channels.length) >> 0;
    for (var /** @type {number} */ i = 0; i < n; i++) {
      if (this.mx_messaging_ChannelSet__channels[i] != null)
        ids.push(this.mx_messaging_ChannelSet__channels[i].id);
      else
        ids.push(null);
    }
    return ids;
  }
};


mx.messaging.ChannelSet.prototype.get__currentChannel = function() {
  return this.mx_messaging_ChannelSet__currentChannel;
};


mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__channelFailoverURIs = function() {
  return this.mx_messaging_ChannelSet__channelFailoverURIs;
};


mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__set__channelFailoverURIs = function(value) {
  this.mx_messaging_ChannelSet__channelFailoverURIs = value;
  var /** @type {number} */ n = (this.mx_messaging_ChannelSet__channels.length) >> 0;
  for (var /** @type {number} */ i = 0; i < n; i++) {
    var /** @type {mx.messaging.Channel} */ channel = this.mx_messaging_ChannelSet__channels[i];
    if (channel == null) {
      break;
    } else if (this.mx_messaging_ChannelSet__channelFailoverURIs[channel.id] != null) {
      channel.failoverURIs = this.mx_messaging_ChannelSet__channelFailoverURIs[channel.id];
    }
  }
};


mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__configured = function() {
  return this.mx_messaging_ChannelSet__configured;
};


mx.messaging.ChannelSet.prototype.get__connected = function() {
  return this.mx_messaging_ChannelSet__connected;
};


mx.messaging.ChannelSet.prototype.get__clustered = function() {
  return this.mx_messaging_ChannelSet__clustered;
};


mx.messaging.ChannelSet.prototype.set__clustered = function(value) {
  if (this.mx_messaging_ChannelSet__clustered != value) {
    if (value) {
      var /** @type {Array} */ ids = this.channelIds;
      var /** @type {number} */ n = (ids.length) >> 0;
      for (var /** @type {number} */ i = 0; i < n; i++) {
        if (ids[i] == null) {
          var /** @type {string} */ message = this.mx_messaging_ChannelSet_resourceManager.getString("messaging", "cannotSetClusteredWithdNullChannelIds");
          throw new mx.errors.IllegalOperationError(message);
        }
      }
    }
    this.mx_messaging_ChannelSet__clustered = value;
  }
};


mx.messaging.ChannelSet.prototype.get__heartbeatInterval = function() {
  return this.mx_messaging_ChannelSet__heartbeatInterval;
};


mx.messaging.ChannelSet.prototype.set__heartbeatInterval = function(value) {
  if (this.mx_messaging_ChannelSet__heartbeatInterval != value) {
    var /** @type {mx.events.PropertyChangeEvent} */ event = mx.events.PropertyChangeEvent.createUpdateEvent(this, "heartbeatInterval", this.mx_messaging_ChannelSet__heartbeatInterval, value);
    this.mx_messaging_ChannelSet__heartbeatInterval = value;
    this.dispatchEvent(event);
    if (this.mx_messaging_ChannelSet__heartbeatInterval > 0 && this.connected) {
      this.scheduleHeartbeat();
    }
  }
};


mx.messaging.ChannelSet.prototype.get__initialDestinationId = function() {
  return this.mx_messaging_ChannelSet__initialDestinationId;
};


mx.messaging.ChannelSet.prototype.set__initialDestinationId = function(value) {
  this.mx_messaging_ChannelSet__initialDestinationId = value;
};


mx.messaging.ChannelSet.prototype.get__messageAgents = function() {
  return this.mx_messaging_ChannelSet__messageAgents;
};


Object.defineProperties(mx.messaging.ChannelSet.prototype, /** @lends {mx.messaging.ChannelSet.prototype} */ {
/**
  * @export
  * @type {boolean} */
authenticated: {
get: mx.messaging.ChannelSet.prototype.get__authenticated},
/**
  * @export
  * @type {Array} */
channels: {
get: mx.messaging.ChannelSet.prototype.get__channels,
set: mx.messaging.ChannelSet.prototype.set__channels},
/**
  * @export
  * @type {Array} */
channelIds: {
get: mx.messaging.ChannelSet.prototype.get__channelIds},
/**
  * @export
  * @type {mx.messaging.Channel} */
currentChannel: {
get: mx.messaging.ChannelSet.prototype.get__currentChannel},
/**
  * @export
  * @type {Object} */
http_$$www_adobe_com$2006$flex$mx$internal__channelFailoverURIs: {
get: mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__channelFailoverURIs,
set: mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__set__channelFailoverURIs},
/**
  * @export
  * @type {boolean} */
http_$$www_adobe_com$2006$flex$mx$internal__configured: {
get: mx.messaging.ChannelSet.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__configured},
/**
  * @export
  * @type {boolean} */
connected: {
get: mx.messaging.ChannelSet.prototype.get__connected},
/**
  * @export
  * @type {boolean} */
clustered: {
get: mx.messaging.ChannelSet.prototype.get__clustered,
set: mx.messaging.ChannelSet.prototype.set__clustered},
/**
  * @export
  * @type {number} */
heartbeatInterval: {
get: mx.messaging.ChannelSet.prototype.get__heartbeatInterval,
set: mx.messaging.ChannelSet.prototype.set__heartbeatInterval},
/**
  * @export
  * @type {string} */
initialDestinationId: {
get: mx.messaging.ChannelSet.prototype.get__initialDestinationId,
set: mx.messaging.ChannelSet.prototype.set__initialDestinationId},
/**
  * @export
  * @type {Array} */
messageAgents: {
get: mx.messaging.ChannelSet.prototype.get__messageAgents}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.ChannelSet.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'ChannelSet', qName: 'mx.messaging.ChannelSet', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.ChannelSet.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'authenticated': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.ChannelSet', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'channels': { type: 'Array', access: 'readwrite', declaredBy: 'mx.messaging.ChannelSet'},
        'channelIds': { type: 'Array', access: 'readonly', declaredBy: 'mx.messaging.ChannelSet'},
        'currentChannel': { type: 'mx.messaging.Channel', access: 'readonly', declaredBy: 'mx.messaging.ChannelSet'},
        'http://www.adobe.com/2006/flex/mx/internal::channelFailoverURIs': { type: 'Object', access: 'readwrite', declaredBy: 'mx.messaging.ChannelSet'},
        'http://www.adobe.com/2006/flex/mx/internal::configured': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.ChannelSet'},
        'connected': { type: 'Boolean', access: 'readonly', declaredBy: 'mx.messaging.ChannelSet', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'clustered': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.messaging.ChannelSet'},
        'heartbeatInterval': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.ChannelSet'},
        'initialDestinationId': { type: 'String', access: 'readwrite', declaredBy: 'mx.messaging.ChannelSet'},
        'messageAgents': { type: 'Array', access: 'readonly', declaredBy: 'mx.messaging.ChannelSet'}
      };
    },
    methods: function () {
      return {
        'ChannelSet': { type: '', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'Array', true ,'Boolean', true ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::setAuthenticated': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'Boolean', false ,'String', false ,'Boolean', true ]; }},
        'toString': { type: 'String', declaredBy: 'mx.messaging.ChannelSet'},
        'addChannel': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.Channel', false ]; }},
        'removeChannel': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.Channel', false ]; }},
        'connect': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.MessageAgent', false ]; }},
        'disconnect': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.MessageAgent', false ]; }},
        'disconnectAll': { type: 'void', declaredBy: 'mx.messaging.ChannelSet'},
        'channelConnectHandler': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.events.ChannelEvent', false ]; }},
        'channelDisconnectHandler': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.events.ChannelEvent', false ]; }},
        'channelFaultHandler': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.events.ChannelFaultEvent', false ]; }},
        'login': { type: 'mx.rpc.AsyncToken', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'String', false ,'String', false ,'String', true ]; }},
        'logout': { type: 'mx.rpc.AsyncToken', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.MessageAgent', true ]; }},
        'send': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'mx.messaging.MessageAgent', false ,'mx.messaging.messages.IMessage', false ]; }},
        'setCredentials': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'String', false ,'mx.messaging.MessageAgent', false ,'String', true ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::authenticationSuccess': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'AuthenticationAgent', false ,'mx.rpc.AsyncToken', false ,'mx.messaging.messages.AcknowledgeMessage', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::authenticationFailure': { type: 'void', declaredBy: 'mx.messaging.ChannelSet', parameters: function () { return [ 'AuthenticationAgent', false ,'mx.rpc.AsyncToken', false ,'mx.messaging.messages.ErrorMessage', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 *  Constructor.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @constructor
 * @extends {mx.messaging.MessageResponder}
 * @param {mx.messaging.messages.IMessage} message
 * @param {mx.messaging.ChannelSet} channelSet
 */
mx.messaging.ChannelSet.ClusterMessageResponder = function(message, channelSet) {
  mx.messaging.ChannelSet.ClusterMessageResponder.base(this, 'constructor', null, message);
  this.ClusterMessageResponder__channelSet = channelSet;
};
goog.inherits(mx.messaging.ChannelSet.ClusterMessageResponder, mx.messaging.MessageResponder);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.ChannelSet.ClusterMessageResponder', mx.messaging.ChannelSet.ClusterMessageResponder);


/**
 * @private
 * @type {mx.messaging.ChannelSet}
 */
mx.messaging.ChannelSet.ClusterMessageResponder.prototype.ClusterMessageResponder__channelSet;


/**
 *  Handles a cluster message response.
 *
 *  @asparam message The response Message.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @override
 */
mx.messaging.ChannelSet.ClusterMessageResponder.prototype.resultHandler = function(message) {
  if ((message.body != null) && (org.apache.royale.utils.Language.is(message.body, Array) || org.apache.royale.utils.Language.is(message.body, mx.collections.ArrayCollection))) {
    var /** @type {Object} */ channelFailoverURIs = {};
    var /** @type {Array} */ mappings = org.apache.royale.utils.Language.is(message.body, Array) ? org.apache.royale.utils.Language.as(message.body, Array) : org.apache.royale.utils.Language.as(message.body, mx.collections.ArrayCollection).toArray();
    var /** @type {number} */ n = (mappings.length) >> 0;
    for (var /** @type {number} */ i = 0; i < n; i++) {
      var /** @type {Object} */ channelToEndpointMap = mappings[i];
      for (var /** @type {Object} */ channelId in channelToEndpointMap) {
        if (channelFailoverURIs[channelId] == null)
          channelFailoverURIs[channelId] = [];
        channelFailoverURIs[channelId].push(channelToEndpointMap[channelId]);
      }
    }
    this.ClusterMessageResponder__channelSet.http_$$www_adobe_com$2006$flex$mx$internal__channelFailoverURIs = channelFailoverURIs;
  }
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.ChannelSet.ClusterMessageResponder.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'ClusterMessageResponder', qName: 'mx.messaging.ChannelSet.ClusterMessageResponder', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.ChannelSet.ClusterMessageResponder.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'ClusterMessageResponder': { type: '', declaredBy: 'mx.messaging.ChannelSet.ClusterMessageResponder', parameters: function () { return [ 'mx.messaging.messages.IMessage', false ,'mx.messaging.ChannelSet', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.ClusterMessageResponder.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 *  @asprivate
 *  Constructor.
 *
 *  @asparam agent The MessageAgent sending the message.
 *
 *  @asparam msg The Message to send.
 * @constructor
 * @param {mx.messaging.MessageAgent} agent
 * @param {mx.messaging.messages.IMessage} message
 */
mx.messaging.ChannelSet.PendingSend = function(agent, message) {
  ;
  this.agent = agent;
  this.message = message;
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.ChannelSet.PendingSend', mx.messaging.ChannelSet.PendingSend);


/**
 * @export
 * @type {mx.messaging.MessageAgent}
 */
mx.messaging.ChannelSet.PendingSend.prototype.agent;


/**
 * @export
 * @type {mx.messaging.messages.IMessage}
 */
mx.messaging.ChannelSet.PendingSend.prototype.message;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.ChannelSet.PendingSend.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'PendingSend', qName: 'mx.messaging.ChannelSet.PendingSend', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.ChannelSet.PendingSend.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'agent': { type: 'mx.messaging.MessageAgent', get_set: function (/** mx.messaging.ChannelSet.PendingSend */ inst, /** * */ v) {return v !== undefined ? inst.agent = v : inst.agent;}},
        'message': { type: 'mx.messaging.messages.IMessage', get_set: function (/** mx.messaging.ChannelSet.PendingSend */ inst, /** * */ v) {return v !== undefined ? inst.message = v : inst.message;}}
      };
    },
    methods: function () {
      return {
        'PendingSend': { type: '', declaredBy: 'mx.messaging.ChannelSet.PendingSend', parameters: function () { return [ 'mx.messaging.MessageAgent', false ,'mx.messaging.messages.IMessage', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.PendingSend.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 *  Constructor.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @constructor
 * @extends {mx.messaging.MessageAgent}
 * @param {mx.messaging.ChannelSet} channelSet
 */
mx.messaging.ChannelSet.AuthenticationAgent = function(channelSet) {
  mx.messaging.ChannelSet.AuthenticationAgent.base(this, 'constructor');
  
  this.AuthenticationAgent_tokens = {};
  this.AuthenticationAgent__state = mx.messaging.ChannelSet.AuthenticationAgent.LOGGED_OUT_STATE;
  this._log = mx.logging.Log.getLogger("ChannelSet.AuthenticationAgent");
  this._agentType = "authentication agent";
  this.channelSet = channelSet;
};
goog.inherits(mx.messaging.ChannelSet.AuthenticationAgent, mx.messaging.MessageAgent);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.messaging.ChannelSet.AuthenticationAgent', mx.messaging.ChannelSet.AuthenticationAgent);


/**
 * @export
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.LOGGED_OUT_STATE = 0;


/**
 * @export
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.LOGGING_IN_STATE = 1;


/**
 * @export
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.LOGGED_IN_STATE = 2;


/**
 * @export
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.LOGGING_OUT_STATE = 3;


/**
 * @export
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE = 4;


/**
 * @private
 * @type {Object}
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.AuthenticationAgent_tokens;


/**
 * @private
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.AuthenticationAgent__state;


/**
 * Registers an outbound login/logout message and its associated token for response/fault handling.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @param {mx.rpc.AsyncToken} token
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.registerToken = function(token) {
  this.AuthenticationAgent_tokens[token.message.messageId] = token;
};


/**
 * Acknowledge message callback.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @override
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.acknowledge = function(ackMsg, msg) {
  if (this.state == mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE)
    return;
  var /** @type {boolean} */ error = !!(ackMsg.headers[mx.messaging.messages.AcknowledgeMessage.ERROR_HINT_HEADER]);
  mx.messaging.ChannelSet.AuthenticationAgent.superClass_.acknowledge.apply(this, [ ackMsg, msg] );
  if (!error) {
    var /** @type {mx.rpc.AsyncToken} */ token = this.AuthenticationAgent_tokens[msg.messageId];
    delete this.AuthenticationAgent_tokens[msg.messageId];
    this.channelSet.http_$$www_adobe_com$2006$flex$mx$internal__authenticationSuccess(this, token, org.apache.royale.utils.Language.as(ackMsg, mx.messaging.messages.AcknowledgeMessage));
  }
};


/**
 * Fault callback.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion BlazeDS 4
 *  @productversion LCDS 3
 * @export
 * @override
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.fault = function(errMsg, msg) {
  if (this.state == mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE)
    return;
  if (org.apache.royale.utils.Language.is(errMsg.rootCause, mx.messaging.events.ChannelEvent) && org.apache.royale.utils.Language.as(errMsg.rootCause, mx.messaging.events.ChannelEvent).type == mx.messaging.events.ChannelEvent.DISCONNECT) {
    var /** @type {mx.messaging.messages.AcknowledgeMessage} */ ackMsg = new mx.messaging.messages.AcknowledgeMessage();
    ackMsg.clientId = this.clientId;
    ackMsg.correlationId = msg.messageId;
    this.acknowledge(ackMsg, msg);
    return;
  }
  mx.messaging.ChannelSet.AuthenticationAgent.superClass_.fault.apply(this, [ errMsg, msg] );
  var /** @type {mx.rpc.AsyncToken} */ token = this.AuthenticationAgent_tokens[msg.messageId];
  delete this.AuthenticationAgent_tokens[msg.messageId];
  this.channelSet.http_$$www_adobe_com$2006$flex$mx$internal__authenticationFailure(this, token, org.apache.royale.utils.Language.as(errMsg, mx.messaging.messages.ErrorMessage));
};


mx.messaging.ChannelSet.AuthenticationAgent.prototype.get__state = function() {
  return this.AuthenticationAgent__state;
};


mx.messaging.ChannelSet.AuthenticationAgent.prototype.set__state = function(value) {
  this.AuthenticationAgent__state = value;
  if (value == mx.messaging.ChannelSet.AuthenticationAgent.SHUTDOWN_STATE)
    this.AuthenticationAgent_tokens = null;
};


Object.defineProperties(mx.messaging.ChannelSet.AuthenticationAgent.prototype, /** @lends {mx.messaging.ChannelSet.AuthenticationAgent.prototype} */ {
/**
  * @export
  * @type {number} */
state: {
get: mx.messaging.ChannelSet.AuthenticationAgent.prototype.get__state,
set: mx.messaging.ChannelSet.AuthenticationAgent.prototype.set__state}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'AuthenticationAgent', qName: 'mx.messaging.ChannelSet.AuthenticationAgent', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'state': { type: 'int', access: 'readwrite', declaredBy: 'mx.messaging.ChannelSet.AuthenticationAgent'}
      };
    },
    methods: function () {
      return {
        'AuthenticationAgent': { type: '', declaredBy: 'mx.messaging.ChannelSet.AuthenticationAgent', parameters: function () { return [ 'mx.messaging.ChannelSet', false ]; }},
        'registerToken': { type: 'void', declaredBy: 'mx.messaging.ChannelSet.AuthenticationAgent', parameters: function () { return [ 'mx.rpc.AsyncToken', false ]; }},
        'acknowledge': { type: 'void', declaredBy: 'mx.messaging.ChannelSet.AuthenticationAgent', parameters: function () { return [ 'mx.messaging.messages.AcknowledgeMessage', false ,'mx.messaging.messages.IMessage', false ]; }},
        'fault': { type: 'void', declaredBy: 'mx.messaging.ChannelSet.AuthenticationAgent', parameters: function () { return [ 'mx.messaging.messages.ErrorMessage', false ,'mx.messaging.messages.IMessage', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.messaging.ChannelSet.AuthenticationAgent.prototype.ROYALE_COMPILE_FLAGS = 26;
