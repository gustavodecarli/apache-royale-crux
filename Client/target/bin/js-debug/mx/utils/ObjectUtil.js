/**
 * Generated by Apache Royale Compiler from mx/utils/ObjectUtil.as
 * mx.utils.ObjectUtil
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.utils.ObjectUtil');
/* Royale Dependency List: QName,XML,XMLList,mx.collections.IList,org.apache.royale.net.remoting.amf.AMFBinaryData,org.apache.royale.reflection.AccessorDefinition,org.apache.royale.reflection.MemberDefinitionBase,org.apache.royale.reflection.MetaDataArgDefinition,org.apache.royale.reflection.MetaDataDefinition,org.apache.royale.reflection.TypeDefinition,org.apache.royale.reflection.VariableDefinition,org.apache.royale.reflection.describeType,org.apache.royale.reflection.getAliasByClass,org.apache.royale.reflection.getDefinitionByName,org.apache.royale.reflection.getDynamicFields,org.apache.royale.reflection.getQualifiedClassName,org.apache.royale.reflection.isDynamicObject,org.apache.royale.reflection.utils.MemberTypes,org.apache.royale.reflection.utils.getMembers,org.apache.royale.utils.BinaryData,org.apache.royale.utils.Language*/
goog.provide('mx.utils.ObjectUtil.ClassInfo');




/**
 * @constructor
 */
mx.utils.ObjectUtil = function() {
};


/**
 * @private
 * @type {Array}
 */
mx.utils.ObjectUtil.defaultToStringExcludes = ["password", "credentials"];


/**
 *  Compares the Objects and returns an integer value
 *  indicating if the first item is less than, greater than, or equal to
 *  the second item.
 *  This method will recursively compare properties on nested objects and
 *  will return as soon as a non-zero result is found.
 *  By default this method will recurse to the deepest level of any property.
 *  To change the depth for comparison specify a non-negative value for
 *  the <code>depth</code> parameter.
 *
 *  @asparam a Object.
 *
 *  @asparam b Object.
 *
 *  @asparam depth Indicates how many levels should be
 *  recursed when performing the comparison.
 *  Set this value to 0 for a shallow comparison of only the primitive
 *  representation of each property.
 *  For example:<pre>
 *  var a:Object = {name:"Bob", info:[1,2,3]};
 *  var b:Object = {name:"Alice", info:[5,6,7]};
 *  var c:int = ObjectUtil.compare(a, b, 0);</pre>
 *
 *  <p>In the above example the complex properties of <code>a</code> and
 *  <code>b</code> will be flattened by a call to <code>toString()</code>
 *  when doing the comparison.
 *  In this case the <code>info</code> property will be turned into a string
 *  when performing the comparison.</p>
 *
 *  @asreturn Return 0 if a and b are equal, or both null or NaN.
 *  Return 1 if a is null or greater than b.
 *  Return -1 if b is null or greater than a.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} a
 * @param {Object} b
 * @param {number=} depth
 * @return {number}
 */
mx.utils.ObjectUtil.compare = function(a, b, depth) {
  depth = typeof depth !== 'undefined' ? depth : -1;
  
  return mx.utils.ObjectUtil.internalCompare(a, b, 0, depth, new WeakMap());
};


/**
 *  Copies the specified Object and returns a reference to the copy.
 *  The copy is made using a native serialization technique.
 *  This means that custom serialization will be respected during the copy.
 *
 *  <p>This method is designed for copying data objects,
 *  such as elements of a collection. It is not intended for copying
 *  a UIComponent object, such as a TextInput control. If you want to create copies
 *  of specific UIComponent objects, you can create a subclass of the component and implement
 *  a <code>clone()</code> method, or other method to perform the copy.</p>
 *
 *  @asparam value Object that should be copied.
 *
 *  @asreturn Copy of the specified Object.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} value
 * @return {Object}
 */
mx.utils.ObjectUtil.copy = function(value) {
  
  var /** @type {org.apache.royale.net.remoting.amf.AMFBinaryData} */ buffer = new org.apache.royale.net.remoting.amf.AMFBinaryData();
  buffer.writeObject(value);
  buffer.position = 0;
  var /** @type {Object} */ result = buffer.readObject();
  return result;
};


/**
 *  Clones the specified Object and returns a reference to the clone.
 *  The clone is made using a native serialization technique.
 *  This means that custom serialization will be respected during the
 *  cloning.  clone() differs from copy() in that the uid property of
 *  each object instance is retained.
 *
 *  <p>This method is designed for cloning data objects,
 *  such as elements of a collection. It is not intended for cloning
 *  a UIComponent object, such as a TextInput control. If you want to clone
 *  specific UIComponent objects, you can create a subclass of the component
 *  and implement a <code>clone()</code> method.</p>
 *
 *  @asparam value Object that should be cloned.
 *
 *  @asreturn Clone of the specified Object.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 4
 * @param {Object} value
 * @return {Object}
 */
mx.utils.ObjectUtil.clone = function(value) {
  var /** @type {Object} */ result = mx.utils.ObjectUtil.copy(value);
  mx.utils.ObjectUtil.cloneInternal(result, value);
  return result;
};


/**
 *  Recursive helper used by the public clone method.
 *  @asprivate
 * @private
 * @param {Object} result
 * @param {Object} value
 */
mx.utils.ObjectUtil.cloneInternal = function(result, value) {
  if (value && value.hasOwnProperty("uid"))
    result.uid = value.uid;
  var /** @type {Object} */ classInfo = mx.utils.ObjectUtil.getClassInfo(value);
  var /** @type {Object} */ v;
  var foreachiter0_target = classInfo.properties;
  for (var foreachiter0 in foreachiter0_target) 
  {
  var p = foreachiter0_target[foreachiter0];
  {
    v = value[p];
    if (v && v.hasOwnProperty("uid"))
      mx.utils.ObjectUtil.cloneInternal(result[p], v);
  }}
  
};


/**
 *  Returns <code>true</code> if the object reference specified
 *  is a simple data type. The simple data types include the following:
 *  <ul>
 *    <li><code>String</code></li>
 *    <li><code>Number</code></li>
 *    <li><code>uint</code></li>
 *    <li><code>int</code></li>
 *    <li><code>Boolean</code></li>
 *    <li><code>Date</code></li>
 *    <li><code>Array</code></li>
 *  </ul>
 *
 *  @asparam value Object inspected.
 *
 *  @asreturn <code>true</code> if the object specified
 *  is one of the types above; <code>false</code> otherwise.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} value
 * @return {boolean}
 */
mx.utils.ObjectUtil.isSimple = function(value) {
  var /** @type {string} */ objectType = typeof(value);
  switch (objectType) {
    case "number":
    
    case "string":
    
    case "boolean":
      return true;
    case "object":
      return org.apache.royale.utils.Language.is(value, Date) || org.apache.royale.utils.Language.is(value, Array);
  }
  return false;
};


/**
 *  Compares two numeric values.
 *
 *  @asparam a First number.
 *
 *  @asparam b Second number.
 *
 *  @asreturn 0 is both numbers are NaN.
 *  1 if only <code>a</code> is a NaN.
 *  -1 if only <code>b</code> is a NaN.
 *  -1 if <code>a</code> is less than <code>b</code>.
 *  1 if <code>a</code> is greater than <code>b</code>.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
mx.utils.ObjectUtil.numericCompare = function(a, b) {
  if (isNaN(a) && isNaN(b))
    return 0;
  if (isNaN(a))
    return 1;
  if (isNaN(b))
    return -1;
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
};


/**
 *  Compares two String values.
 *
 *  @asparam a First String value.
 *
 *  @asparam b Second String value.
 *
 *  @asparam caseInsensitive Specifies to perform a case insensitive compare,
 *  <code>true</code>, or not, <code>false</code>.
 *
 *  @asreturn 0 is both Strings are null.
 *  1 if only <code>a</code> is null.
 *  -1 if only <code>b</code> is null.
 *  -1 if <code>a</code> precedes <code>b</code>.
 *  1 if <code>b</code> precedes <code>a</code>.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {string} a
 * @param {string} b
 * @param {boolean=} caseInsensitive
 * @return {number}
 */
mx.utils.ObjectUtil.stringCompare = function(a, b, caseInsensitive) {
  caseInsensitive = typeof caseInsensitive !== 'undefined' ? caseInsensitive : false;
  if (a == null && b == null)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  if (caseInsensitive) {
    a = a.toLocaleLowerCase();
    b = b.toLocaleLowerCase();
  }
  var /** @type {number} */ result = (a.localeCompare(b)) >> 0;
  if (result < -1)
    result = -1;
  else if (result > 1)
    result = 1;
  return result;
};


/**
 *  Compares the two Date objects and returns an integer value
 *  indicating if the first Date object is before, equal to,
 *  or after the second item.
 *
 *  @asparam a Date object.
 *
 *  @asparam b Date object.
 *
 *  @asreturn 0 if <code>a</code> and <code>b</code> are equal
 *  (or both are <code>null</code>);
 *  -1 if <code>a</code> is before <code>b</code>
 *  (or <code>b</code> is <code>null</code>);
 *  1 if <code>a</code> is after <code>b</code>
 *  (or <code>a</code> is <code>null</code>);
 *  0 is both dates getTime's are NaN;
 *  1 if only <code>a</code> getTime is a NaN;
 *  -1 if only <code>b</code> getTime is a NaN.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Date} a
 * @param {Date} b
 * @return {number}
 */
mx.utils.ObjectUtil.dateCompare = function(a, b) {
  if (a == null && b == null)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  var /** @type {number} */ na = a.getTime();
  var /** @type {number} */ nb = b.getTime();
  if (na < nb)
    return -1;
  if (na > nb)
    return 1;
  if (isNaN(na) && isNaN(nb))
    return 0;
  if (isNaN(na))
    return 1;
  if (isNaN(nb))
    return -1;
  return 0;
};


/**
 *  Pretty-prints the specified Object into a String.
 *  All properties will be in alpha ordering.
 *  Each object will be assigned an id during printing;
 *  this value will be displayed next to the object type token
 *  preceded by a '#', for example:
 *
 *  <pre>
 *  (mx.messaging.messages::AsyncMessage)#2.</pre>
 *
 *  <p>This id is used to indicate when a circular reference occurs.
 *  Properties of an object that are of the <code>Class</code> type will
 *  appear only as the assigned type.
 *  For example a custom definition like the following:</p>
 *
 *  <pre>
 *    public class MyCustomClass {
 *      public var clazz:Class;
 *    }</pre>
 *
 *  <p>With the <code>clazz</code> property assigned to <code>Date</code>
 *  will display as shown below:</p>
 *
 *  <pre>
 *   (somepackage::MyCustomClass)#0
 *      clazz = (Date)</pre>
 *
 *  @asparam value Object to be pretty printed.
 *
 *  @asparam namespaceURIs Array of namespace URIs for properties
 *  that should be included in the output.
 *  By default only properties in the public namespace will be included in
 *  the output.
 *  To get all properties regardless of namespace pass an array with a
 *  single element of "*".
 *
 *  @asparam exclude Array of the property names that should be
 *  excluded from the output.
 *  Use this to remove data from the formatted string.
 *
 *  @asreturn String containing the formatted version
 *  of the specified object.
 *
 *  @example
 *  <pre>
 *  // example 1
 *  var obj:AsyncMessage = new AsyncMessage();
 *  obj.body = [];
 *  obj.body.push(new AsyncMessage());
 *  obj.headers["1"] = { name: "myName", num: 15.3};
 *  obj.headers["2"] = { name: "myName", num: 15.3};
 *  obj.headers["10"] = { name: "myName", num: 15.3};
 *  obj.headers["11"] = { name: "myName", num: 15.3};
 *  trace(ObjectUtil.toString(obj));
 *
 *  // will output to flashlog.txt
 *  (mx.messaging.messages::AsyncMessage)#0
 *    body = (Array)#1
 *      [0] (mx.messaging.messages::AsyncMessage)#2
 *        body = (Object)#3
 *        clientId = (Null)
 *        correlationId = ""
 *        destination = ""
 *        headers = (Object)#4
 *        messageId = "378CE96A-68DB-BC1B-BCF7FFFFFFFFB525"
 *        sequenceId = (Null)
 *        sequencePosition = 0
 *        sequenceSize = 0
 *        timeToLive = 0
 *        timestamp = 0
 *    clientId = (Null)
 *    correlationId = ""
 *    destination = ""
 *    headers = (Object)#5
 *      1 = (Object)#6
 *        name = "myName"
 *        num = 15.3
 *      10 = (Object)#7
 *        name = "myName"
 *        num = 15.3
 *      11 = (Object)#8
 *        name = "myName"
 *        num = 15.3
 *      2 = (Object)#9
 *        name = "myName"
 *        num = 15.3
 *    messageId = "1D3E6E96-AC2D-BD11-6A39FFFFFFFF517E"
 *    sequenceId = (Null)
 *    sequencePosition = 0
 *    sequenceSize = 0
 *    timeToLive = 0
 *    timestamp = 0
 *
 *  // example 2 with circular references
 *  obj = {};
 *  obj.prop1 = new Date();
 *  obj.prop2 = [];
 *  obj.prop2.push(15.2);
 *  obj.prop2.push("testing");
 *  obj.prop2.push(true);
 *  obj.prop3 = {};
 *  obj.prop3.circular = obj;
 *  obj.prop3.deeper = new ErrorMessage();
 *  obj.prop3.deeper.rootCause = obj.prop3.deeper;
 *  obj.prop3.deeper2 = {};
 *  obj.prop3.deeper2.deeperStill = {};
 *  obj.prop3.deeper2.deeperStill.yetDeeper = obj;
 *  trace(ObjectUtil.toString(obj));
 *
 *  // will output to flashlog.txt
 *  (Object)#0
 *    prop1 = Tue Apr 26 13:59:17 GMT-0700 2005
 *    prop2 = (Array)#1
 *      [0] 15.2
 *      [1] "testing"
 *      [2] true
 *    prop3 = (Object)#2
 *      circular = (Object)#0
 *      deeper = (mx.messaging.messages::ErrorMessage)#3
 *        body = (Object)#4
 *        clientId = (Null)
 *        code = (Null)
 *        correlationId = ""
 *        destination = ""
 *        details = (Null)
 *        headers = (Object)#5
 *        level = (Null)
 *        message = (Null)
 *        messageId = "14039376-2BBA-0D0E-22A3FFFFFFFF140A"
 *        rootCause = (mx.messaging.messages::ErrorMessage)#3
 *        sequenceId = (Null)
 *        sequencePosition = 0
 *        sequenceSize = 0
 *        timeToLive = 0
 *        timestamp = 0
 *      deeper2 = (Object)#6
 *        deeperStill = (Object)#7
 *          yetDeeper = (Object)#0
 *
 * // example 3 with Dictionary
 * var point:Point = new Point(100, 100);
 * var point2:Point = new Point(100, 100);
 * var obj:Dictionary = new Dictionary();
 * obj[point] = "point";
 * obj[point2] = "point2";
 * obj["1"] = { name: "one", num: 1};
 * obj["two"] = { name: "2", num: 2};
 * obj[3] = 3;
 * trace(ObjectUtil.toString(obj));
 *
 * // will output to flashlog.txt
 * (flash.utils::Dictionary)#0
 *   {(flash.geom::Point)#1
 *     length = 141.4213562373095
 *     x = 100
 *     y = 100} = "point2"
 *   {(flash.geom::Point)#2
 *     length = 141.4213562373095
 *     x = 100
 *     y = 100} = "point"
 *   {1} = (Object)#3
 *     name = "one"
 *     num = 1
 *   {3} = 3
 *   {"two"} = (Object)#4
 *     name = "2"
 *     num = 2
 *
 * </pre>
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 *
 * @param {Object} value
 * @param {Array=} namespaceURIs
 * @param {Array=} exclude
 * @return {string}
 */
mx.utils.ObjectUtil.toString = function(value, namespaceURIs, exclude) {
  namespaceURIs = typeof namespaceURIs !== 'undefined' ? namespaceURIs : null;
  exclude = typeof exclude !== 'undefined' ? exclude : null;
  if (exclude == null) {
    exclude = mx.utils.ObjectUtil.defaultToStringExcludes;
  }
  mx.utils.ObjectUtil.refCount = 0;
  return mx.utils.ObjectUtil.internalToString(value, 0, null, namespaceURIs, exclude);
};


/**
 *  This method cleans up all of the additional parameters that show up in AsDoc
 *  code hinting tools that developers shouldn't ever see.
 *  @asprivate
 *
 *  @royaleignorecoercion WeakMap
 * @private
 * @param {Object} value
 * @param {number=} indent
 * @param {Object=} refs
 * @param {Array=} namespaceURIs
 * @param {Array=} exclude
 * @return {string}
 */
mx.utils.ObjectUtil.internalToString = function(value, indent, refs, namespaceURIs, exclude) {
  indent = typeof indent !== 'undefined' ? indent : 0;
  refs = typeof refs !== 'undefined' ? refs : null;
  namespaceURIs = typeof namespaceURIs !== 'undefined' ? namespaceURIs : null;
  exclude = typeof exclude !== 'undefined' ? exclude : null;
  var /** @type {string} */ str;
  var /** @type {string} */ objectType = value == null ? "null" : typeof(value);
  
  switch (objectType) {
    case "boolean":
    
    case "number":
      return value.toString();
    case "string":
      return "\"" + value.toString() + "\"";
    case "object":
      
      if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList)) {
        return org.apache.royale.utils.Language.string(value.toXMLString());
      }
      if (org.apache.royale.utils.Language.is(value, Date)) {
        return value.toString();
      } else if (org.apache.royale.utils.Language.is(value, org.apache.royale.utils.Language.synthType('Class'))) {
        return "(" + org.apache.royale.reflection.getQualifiedClassName(value) + ")";
      } else {
        var /** @type {Object} */ classInfo = mx.utils.ObjectUtil.getClassInfo(value, exclude, {includeReadOnly:true, uris:namespaceURIs});
        var /** @type {Array} */ properties = classInfo.properties;
        str = "(" + classInfo.name + ")";
        
        if (refs == null)
          refs = new WeakMap();
        try {
          var /** @type {Object} */ id;
          
          id = refs.get(value);
          if (id != null) {
            str += "#" + org.apache.royale.utils.Language._int(id);
            return str;
          }
        } catch (e) {
          return String(value);
        }
        if (value != null) {
          str += "#" + mx.utils.ObjectUtil.refCount.toString();
          
          refs.set(value, mx.utils.ObjectUtil.refCount);
          mx.utils.ObjectUtil.refCount++;
        }
        var /** @type {boolean} */ isArray = org.apache.royale.utils.Language.is(value, Array);
        var /** @type {boolean} */ isDict;
        
        isDict = value instanceof Map || value instanceof WeakMap;
        var /** @type {*} */ prop;
        indent += 2;
        for (var /** @type {number} */ j = 0; j < properties.length; j++) {
          str = mx.utils.ObjectUtil.newline(str, indent);
          prop = properties[j];
          if (isArray)
            str += "[";
          else if (isDict)
            str += "{";
          if (isDict) {
            
            str += " Map or WeakMap key (not stringified) ";
          } else {
            str += prop.toString();
          }
          if (isArray)
            str += "] ";
          else if (isDict)
            str += "} = ";
          else
            str += " = ";
          try {
            var /** @type {Object} */ val;
            if (isDict)
              val = value.get(prop);
            else
              val = value[prop];
            
            str += mx.utils.ObjectUtil.internalToString(val, indent, refs, namespaceURIs, exclude);
          } catch (e) {
            str += "?";
          }
        }
        indent -= 2;
        return str;
      }
      break;
    default:
      return "(" + objectType + ")";
  }
  return "(unknown)";
};


/**
 *  @asprivate
 *  This method will append a newline and the specified number of spaces
 *  to the given string.
 *
 * @private
 * @param {string} str
 * @param {number=} n
 * @return {string}
 */
mx.utils.ObjectUtil.newline = function(str, n) {
  n = typeof n !== 'undefined' ? n : 0;
  var /** @type {string} */ result = str;
  result += "\n";
  for (var /** @type {number} */ i = 0; i < n; i++) {
    result += " ";
  }
  return result;
};


/**
 *  @royaleignorecoercion WeakMap
 *  @royaleignorecoercion BinaryData
 * @private
 * @param {Object} a
 * @param {Object} b
 * @param {number} currentDepth
 * @param {number} desiredDepth
 * @param {Object} refs
 * @return {number}
 */
mx.utils.ObjectUtil.internalCompare = function(a, b, currentDepth, desiredDepth, refs) {
  if (a == null && b == null)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  var /** @type {string} */ typeOfA = typeof(a);
  var /** @type {string} */ typeOfB = typeof(b);
  var /** @type {number} */ result = 0;
  if (typeOfA == typeOfB) {
    switch (typeOfA) {
      case "boolean":
        result = mx.utils.ObjectUtil.numericCompare(Number(a), Number(b));
        break;
      case "number":
        result = mx.utils.ObjectUtil.numericCompare(org.apache.royale.utils.Language.as(a, Number), org.apache.royale.utils.Language.as(b, Number));
        break;
      case "string":
        result = mx.utils.ObjectUtil.stringCompare(org.apache.royale.utils.Language.as(a, String), org.apache.royale.utils.Language.as(b, String));
        break;
      case "object":
        var /** @type {number} */ newDepth = (desiredDepth > 0 ? desiredDepth - 1 : desiredDepth) >> 0;
        
        
/**
 * @const
 * @type {Object}
 */
var byteArrayClass = org.apache.royale.utils.BinaryData;
        var /** @type {Object} */ aRef = mx.utils.ObjectUtil.getRef(a, refs);
        var /** @type {Object} */ bRef = mx.utils.ObjectUtil.getRef(b, refs);
        if (aRef == bRef)
          return 0;
        
        refs.set(bRef, aRef);
        if (desiredDepth != -1 && (currentDepth > desiredDepth)) {
          result = mx.utils.ObjectUtil.stringCompare(a.toString(), b.toString());
        } else if (org.apache.royale.utils.Language.is(a, Array) && org.apache.royale.utils.Language.is(b, Array)) {
          result = mx.utils.ObjectUtil.arrayCompare(org.apache.royale.utils.Language.as(a, Array), org.apache.royale.utils.Language.as(b, Array), currentDepth, desiredDepth, refs);
        } else if (org.apache.royale.utils.Language.is(a, Date) && org.apache.royale.utils.Language.is(b, Date)) {
          result = mx.utils.ObjectUtil.dateCompare(org.apache.royale.utils.Language.as(a, Date), org.apache.royale.utils.Language.as(b, Date));
        } else if (org.apache.royale.utils.Language.is(a, mx.collections.IList) && org.apache.royale.utils.Language.is(b, mx.collections.IList)) {
          result = mx.utils.ObjectUtil.listCompare(org.apache.royale.utils.Language.as(a, mx.collections.IList), org.apache.royale.utils.Language.as(b, mx.collections.IList), currentDepth, desiredDepth, refs);
        } else if (org.apache.royale.utils.Language.is(a, byteArrayClass) && org.apache.royale.utils.Language.is(b, byteArrayClass)) {
          
          result = mx.utils.ObjectUtil.byteArrayCompare(org.apache.royale.utils.Language.as(a, org.apache.royale.utils.BinaryData), org.apache.royale.utils.Language.as(b, org.apache.royale.utils.BinaryData));
        } else if (org.apache.royale.reflection.getQualifiedClassName(a) == org.apache.royale.reflection.getQualifiedClassName(b)) {
          var /** @type {Array} */ aProps = mx.utils.ObjectUtil.getClassInfo(a).properties;
          var /** @type {Array} */ bProps;
          var /** @type {boolean} */ isObjectDynamic = mx.utils.ObjectUtil.isDynamicObject(a);
          if (isObjectDynamic) {
            bProps = mx.utils.ObjectUtil.getClassInfo(b).properties;
            result = mx.utils.ObjectUtil.arrayCompare(aProps, bProps, currentDepth, newDepth, refs);
            if (result != 0)
              return result;
          }
          var /** @type {QName} */ propName;
          var /** @type {Object} */ aProp;
          var /** @type {Object} */ bProp;
          for (var /** @type {number} */ i = 0; i < aProps.length; i++) {
            propName = aProps[i];
            aProp = a[propName.objectAccessFormat()];
            bProp = b[propName.objectAccessFormat()];
            result = mx.utils.ObjectUtil.internalCompare(aProp, bProp, (currentDepth + 1) >> 0, newDepth, refs);
            if (result != 0) {
              return result;
            }
          }
        } else {
          return 1;
        }
        break;
      default:
        break;
    }
  } else {
    return mx.utils.ObjectUtil.stringCompare(typeOfA, typeOfB);
  }
  return result;
};


/**
 * @private
 * @type {boolean}
 */
mx.utils.ObjectUtil._debugCheck;


/**
 * @type {boolean}
 */
mx.utils.ObjectUtil.USE_DOUBLE_COLON = true;


/**
 *  Returns information about the class, and properties of the class, for
 *  the specified Object.
 *
 *  @asparam obj The Object to inspect.
 *
 *  @asparam excludes Array of Strings specifying the property names that should be
 *  excluded from the returned result. For example, you could specify
 *  <code>["currentTarget", "target"]</code> for an Event object since these properties
 *  can cause the returned result to become large.
 *
 *  @asparam options An Object containing one or more properties
 *  that control the information returned by this method.
 *  The properties include the following:
 *
 *  <ul>
 *    <li><code>includeReadOnly</code>: If <code>false</code>,
 *      exclude Object properties that are read-only.
 *      The default value is <code>true</code>.</li>
 *  <li><code>includeTransient</code>: If <code>false</code>,
 *      exclude Object properties and variables that have <code>[Transient]</code> metadata.
 *      The default value is <code>true</code>.</li>
 *  <li><code>uris</code>: Array of Strings of all namespaces that should be included in the output.
 *      It does allow for a wildcard of "~~".
 *      By default, it is null, meaning no namespaces should be included.
 *      For example, you could specify <code>["mx_internal", "mx_object"]</code>
 *      or <code>["~~"]</code>.</li>
 *  </ul>
 *
 *  @asreturn An Object containing the following properties:
 *  <ul>
 *    <li><code>name</code>: String containing the name of the class.</li>
 *    <li><code>properties</code>: Sorted list of the property names of the specified object,
 *    or references to the original key if the specified object is a Dictionary. The individual
 *    array elements are QName instances, which contain both the local name of the property as well as the URI.</li>
 *  </ul>
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 *
 *  @royaleignorecoercion Class
 *  @royaleignorecoercion Map
 *  @royaleignorecoercion WeakMap
 * @param {Object} obj
 * @param {Array=} excludes
 * @param {Object=} options
 * @return {mx.utils.ObjectUtil.ClassInfo}
 */
mx.utils.ObjectUtil.getClassInfo = function(obj, excludes, options) {
  excludes = typeof excludes !== 'undefined' ? excludes : null;
  options = typeof options !== 'undefined' ? options : null;
  var /** @type {number} */ i = 0;
  var /** @type {number} */ n = 0;
  if (options == null)
    options = {includeReadOnly:true, uris:null, includeTransient:true};
  //var /** @type {number} */ n = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {string} */ p;
  var /** @type {mx.utils.ObjectUtil.ClassInfo} */ result;
  var /** @type {Array} */ properties;
  var /** @type {Array} */ propertyNames = [];
  var /** @type {string} */ cacheKey;
  var /** @type {string} */ className;
  var /** @type {string} */ classAlias = '';
  var /** @type {boolean} */ isDynamic = false;
  var /** @type {Object} */ metadataInfo;
  var /** @type {org.apache.royale.reflection.MemberDefinitionBase} */ prop;
  var /** @type {Object} */ excludeObject = {};
  if (excludes) {
    n = (excludes.length) >> 0;
    for (i = 0; i < n; i++) {
      excludeObject[excludes[i]] = 1;
    }
  }
  if (org.apache.royale.utils.Language.is(obj, XML) || org.apache.royale.utils.Language.is(obj, XMLList)) {
    className = "XML";
    classAlias = null;
    var /** @type {XMLList} */ xmlproperties = obj.text();
    if (xmlproperties.length())
      propertyNames.push("*");
    xmlproperties = obj.attributes();
    n = xmlproperties.length();
    for (i = 0; i < n; i++) {
      p = org.apache.royale.utils.Language.string(xmlproperties[i].name());
      if (excludeObject[p] != 1)
        propertyNames.push(new QName("", "@" + p));
    }
  } else {
    var /** @type {org.apache.royale.reflection.TypeDefinition} */ classInfo = org.apache.royale.reflection.describeType(obj);
    if (classInfo == null) {
      if (obj && obj.constructor != Object) {
        className = org.apache.royale.reflection.getQualifiedClassName(obj);
        if (mx.utils.ObjectUtil.USE_DOUBLE_COLON) {
          i = (className.lastIndexOf('.')) >> 0;
          if (i != -1) {
            className = className.substr(0, i) + '::' + className.substr(i + 1);
          }
        }
        if (goog.DEBUG) {
          if (!mx.utils.ObjectUtil._debugCheck) {
            mx.utils.ObjectUtil._debugCheck = true;
            if (org.apache.royale.reflection.describeType([]) == null) {
              console.warn("You may need to add ExtraData to support this application's reflection Requirements. Check Reflection Beads for 'ExtraReflectionDataBead'. This warning will not appear in release builds");
              console.warn("This warning was generated when trying to classify :", obj);
            }
          }
        }
      }
      else
        className = "Object";
      isDynamic = true;
    } else {
      className = classInfo.qualifiedName;
      classAlias = org.apache.royale.reflection.getAliasByClass( /** @type {Object|null} */ (org.apache.royale.reflection.getDefinitionByName(className))) || '';
      if (mx.utils.ObjectUtil.USE_DOUBLE_COLON) {
        i = (className.lastIndexOf('.')) >> 0;
        if (i != -1) {
          className = className.substr(0, i) + '::' + className.substr(i + 1);
        }
      }
      isDynamic = org.apache.royale.reflection.isDynamicObject(obj);
      
/**
 * @const
 * @type {boolean}
 */
var isClass = org.apache.royale.utils.Language.is(obj, org.apache.royale.utils.Language.synthType('Class'));
      var /** @type {number} */ selectors = (org.apache.royale.reflection.utils.MemberTypes.ACCESSORS | org.apache.royale.reflection.utils.MemberTypes.VARIABLES) >>> 0;
      if (isClass)
        selectors |= org.apache.royale.reflection.utils.MemberTypes.STATIC_ONLY;
      properties = org.apache.royale.reflection.utils.getMembers(classInfo, isClass, selectors);
      n = (properties.length) >> 0;
      for (i = 0; i < n; i++) {
        var /** @type {org.apache.royale.reflection.AccessorDefinition} */ accessor = org.apache.royale.utils.Language.as(properties[i], org.apache.royale.reflection.AccessorDefinition);
        if (accessor) {
          var /** @type {boolean} */ includeAccessor = !!(accessor.access == 'readwrite' || (options.includeReadOnly && accessor.access == 'readonly'));
          if (!includeAccessor) {
            properties.splice(i, 1);
            i--;
          }
        }
      }
      var /** @type {boolean} */ numericIndex = false;
    }
  }
  if (!isDynamic && className != "XML") {
    cacheKey = mx.utils.ObjectUtil.getCacheKey(obj, excludes, options);
    result = mx.utils.ObjectUtil.CLASS_INFO_CACHE[cacheKey];
    if (result != null)
      return result;
  }
  if (!properties)
    properties = [];
  result = new mx.utils.ObjectUtil.ClassInfo();
  result.name = className;
  result.alias = classAlias;
  result.properties = propertyNames;
  result.dynamic = isDynamic;
  result.metadata = metadataInfo = mx.utils.ObjectUtil.recordMetadata(properties);
  var /** @type {boolean} */ isArray = org.apache.royale.utils.Language.is(obj, Array);
  var /** @type {boolean} */ isDict = (obj instanceof Map || obj instanceof WeakMap);
  if (isDict) {
    if (obj instanceof WeakMap)
      throw new Error('WeakMap cannot be enumerated, use Map instead');
    obj.forEach(function(value, key) {
      propertyNames.push(key);
    });
  } else if (isDynamic) {
    var /** @type {Array} */ dynFields = org.apache.royale.reflection.getDynamicFields(obj);
    while (dynFields.length) {
      p = org.apache.royale.utils.Language.string(dynFields.shift());
      if (excludeObject[p] != 1) {
        if (isArray) {
          var /** @type {number} */ pi = parseInt(p, undefined);
          if (isNaN(pi))
            propertyNames.push(new QName("", p));
          else
            propertyNames.push(pi);
        } else {
          propertyNames.push(new QName("", p));
        }
      }
    }
    numericIndex = isArray && !isNaN(Number(p));
  }
  if (isArray || isDict || className == "Object") {
  } else if (className == "XML") {
    n = (properties.length) >> 0;
    for (i = 0; i < n; i++) {
      p = org.apache.royale.utils.Language.string(properties[i].name());
      if (excludeObject[p] != 1)
        propertyNames.push(new QName("", "@" + p));
    }
  } else {
    n = (properties.length) >> 0;
    var /** @type {Array} */ uris = options.uris;
    var /** @type {string} */ uri;
    var /** @type {QName} */ qName;
    for (i = 0; i < n; i++) {
      prop = properties[i];
      p = prop.name;
      uri = prop.uri;
      if (excludeObject[p] == 1)
        continue;
      if (!options.includeTransient && mx.utils.ObjectUtil.internalHasMetadata(metadataInfo, p, "Transient"))
        continue;
      if (uris != null) {
        if (uris.length == 1 && uris[0] == "*") {
          qName = new QName(uri, p);
          propertyNames.push(qName);
        } else {
          for (var /** @type {number} */ j = 0; j < uris.length; j++) {
            uri = org.apache.royale.utils.Language.string(uris[j]);
            if (prop.uri == uri) {
              qName = new QName(uri, p);
              propertyNames.push(qName);
            }
          }
        }
      } else if (uri.length == 0) {
        qName = new QName(uri, p);
        propertyNames.push(qName);
      }
    }
  }
  org.apache.royale.utils.Language.sort(propertyNames, 1 | (numericIndex ? 16 : 0));
  if (!isDict) {
    for (i = 0; i < propertyNames.length - 1; i++) {
      if (propertyNames[i].toString() == propertyNames[i + 1].toString()) {
        propertyNames.splice(i, 1);
        i--;
      }
    }
  }
  if (!isDynamic && className != "XML") {
    cacheKey = mx.utils.ObjectUtil.getCacheKey(obj, excludes, options);
    mx.utils.ObjectUtil.CLASS_INFO_CACHE[cacheKey] = result;
  }
  return result;
};


/**
 * Uses <code>getClassInfo</code> and examines the metadata information to
 * determine whether a property on a given object has the specified
 * metadata.
 *
 * @asparam obj The object holding the property.
 * @asparam propName The property to check for metadata.
 * @asparam metadataName The name of the metadata to check on the property.
 * @asparam excludes If any properties need to be excluded when generating class info. (Optional)
 * @asparam options If any options flags need to changed when generating class info. (Optional)
 * @asreturn true if the property has the specified metadata.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} obj
 * @param {string} propName
 * @param {string} metadataName
 * @param {Array=} excludes
 * @param {Object=} options
 * @return {boolean}
 */
mx.utils.ObjectUtil.hasMetadata = function(obj, propName, metadataName, excludes, options) {
  excludes = typeof excludes !== 'undefined' ? excludes : null;
  options = typeof options !== 'undefined' ? options : null;
  var /** @type {Object} */ classInfo = mx.utils.ObjectUtil.getClassInfo(obj, excludes, options);
  var /** @type {Object} */ metadataInfo = classInfo.metadata;
  return mx.utils.ObjectUtil.internalHasMetadata(metadataInfo, propName, metadataName);
};


/**
 *  Returns <code>true</code> if the object is an instance of a dynamic class.
 *
 *  @asparam object The object.
 *
 *  @asreturn <code>true</code> if the object is an instance of a dynamic class.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} object
 * @return {boolean}
 */
mx.utils.ObjectUtil.isDynamicObject = function(object) {
  return org.apache.royale.reflection.isDynamicObject(object);
};


/**
 *  Returns all the properties defined dynamically on an object.
 *
 *  @asparam object The object to inspect.
 *
 *  @asreturn an <code>Array</code> of the enumerable properties of the object.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} object
 * @return {Array}
 */
mx.utils.ObjectUtil.getEnumerableProperties = function(object) {
  return org.apache.royale.reflection.getDynamicFields(object, null, true, true);
};


/**
 *  Verifies if the first object is dynamic and is a subset of the second object.
 *
 *  @asparam values The values which need to be shared by <code>object</code>
 *  @asparam object The object to verify against.
 *
 *  @asreturn true if and only if the objects are the same, or if <code>values</code>
 *  is dynamic and <code>object</code> shares all its properties and values.
 *  (Even if <code>object</code> contains other properties and values, we still
 *  consider it a match).
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} values
 * @param {Object} object
 * @return {boolean}
 */
mx.utils.ObjectUtil.valuesAreSubsetOfObject = function(values, object) {
  if (!object && !values)
    return true;
  if (!object || !values)
    return false;
  if (object === values)
    return true;
  var /** @type {Array} */ enumerableProperties = mx.utils.ObjectUtil.getEnumerableProperties(values);
  var /** @type {boolean} */ matches = enumerableProperties.length > 0 || mx.utils.ObjectUtil.isDynamicObject(values);
  var foreachiter1_target = enumerableProperties;
  for (var foreachiter1 in foreachiter1_target) 
  {
  var property = foreachiter1_target[foreachiter1];
  {
    if (!object.hasOwnProperty(property) || object[property] != values[property]) {
      matches = false;
      break;
    }
  }}
  
  return matches;
};


/**
 *  Returns the value at the end of the property chain <code>path</code>.
 *  If the value cannot be reached due to null links on the chain,
 *  <code>undefined</code> is returned.
 *
 *  @asparam obj The object at the beginning of the property chain
 *  @asparam path The path to inspect (e.g. "address.street")
 *
 *  @asreturn the value at the end of the property chain, <code>undefined</code>
 *  if it cannot be reached, or the object itself when <code>path</code> is empty.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} obj
 * @param {Array} path
 * @return {*}
 */
mx.utils.ObjectUtil.getValue = function(obj, path) {
  if (!obj)
    return undefined;
  if (!path || !path.length)
    return obj;
  var /** @type {*} */ result = obj;
  var /** @type {number} */ i = -1;
  
  while (++i < path.length && result) {
    result = path[i] in result ? result[path[i]] : undefined;
  }
  return result;
};


/**
 *  Sets a new value at the end of the property chain <code>path</code>.
 *  If the value cannot be reached due to null links on the chain,
 *  <code>false</code> is returned.
 *
 *  @asparam obj The object at the beginning of the property chain
 *  @asparam path The path to traverse (e.g. "address.street")
 *  @asparam newValue The value to set (e.g. "Fleet Street")
 *
 *  @asreturn <code>true</code> if the value is successfully set,
 *  <code>false</code> otherwise. Note that the function does not
 *  use a try/catch block. You can implement one in the calling
 *  function if there's a risk of type mismatch or other errors during
 *  the assignment.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @param {Object} obj
 * @param {Array} path
 * @param {*} newValue
 * @return {boolean}
 */
mx.utils.ObjectUtil.setValue = function(obj, path, newValue) {
  if (!obj || !path || !path.length)
    return false;
  var /** @type {*} */ secondToLastLink = mx.utils.ObjectUtil.getValue(obj, path.slice(0, -1));
  
  if (secondToLastLink && (path[path.length - 1] in secondToLastLink)) {
    secondToLastLink[path[path.length - 1]] = newValue;
    return true;
  }
  return false;
};


/**
 *  @asprivate
 * @private
 * @param {Object} metadataInfo
 * @param {string} propName
 * @param {string} metadataName
 * @return {boolean}
 */
mx.utils.ObjectUtil.internalHasMetadata = function(metadataInfo, propName, metadataName) {
  if (metadataInfo != null) {
    var /** @type {Object} */ metadata = metadataInfo[propName];
    if (metadata != null) {
      if (metadata[metadataName] != null)
        return true;
    }
  }
  return false;
};


/**
 *  @asprivate
 * @private
 * @param {Array} properties
 * @return {Object}
 */
mx.utils.ObjectUtil.recordMetadata = function(properties) {
  var /** @type {Object} */ result = null;
  try {
    var foreachiter2_target = properties;
    for (var foreachiter2 in foreachiter2_target) 
    {
    var prop = foreachiter2_target[foreachiter2];
    {
      var /** @type {string} */ propName = prop.name;
      var /** @type {Array} */ metadataList = prop.metadata;
      if (metadataList.length) {
        if (result == null)
          result = {};
        var /** @type {Object} */ metadata = {};
        result[propName] = metadata;
        var foreachiter3_target = metadataList;
        for (var foreachiter3 in foreachiter3_target) 
        {
        var md = foreachiter3_target[foreachiter3];
        {
          var /** @type {string} */ mdName = md.name;
          var /** @type {Array} */ argsList = md.args;
          var /** @type {Object} */ value = {};
          var foreachiter4_target = argsList;
          for (var foreachiter4 in foreachiter4_target) 
          {
          var arg = foreachiter4_target[foreachiter4];
          {
            var /** @type {string} */ argKey = arg.key;
            if (argKey != null) {
              var /** @type {string} */ argValue = arg.value;
              value[argKey] = argValue;
            }
          }}
          
          var /** @type {Object} */ existing = metadata[mdName];
          if (existing != null) {
            var /** @type {Array} */ existingArray;
            if (org.apache.royale.utils.Language.is(existing, Array))
              existingArray = org.apache.royale.utils.Language.as(existing, Array); else {
              existingArray = [existing];
              delete metadata[mdName];
            }
            existingArray.push(value);
            existing = existingArray;
          } else {
            existing = value;
          }
          metadata[mdName] = existing;
        }}
        
      }
    }}
    
  } catch (e) {
  }
  return result;
};


/**
 *  @asprivate
 * @private
 * @param {Object} o
 * @param {Array=} excludes
 * @param {Object=} options
 * @return {string}
 */
mx.utils.ObjectUtil.getCacheKey = function(o, excludes, options) {
  excludes = typeof excludes !== 'undefined' ? excludes : null;
  options = typeof options !== 'undefined' ? options : null;
  var /** @type {string} */ key = org.apache.royale.reflection.getQualifiedClassName(o);
  if (excludes != null) {
    var /** @type {number} */ length = (excludes.length) >> 0;
    for (var /** @type {number} */ i = 0; i < length; i++) {
      var /** @type {string} */ excl = org.apache.royale.utils.Language.as(excludes[i], String);
      if (excl != null)
        key += excl;
    }
  }
  if (options != null) {
    for (var /** @type {string} */ flag in options) {
      key += flag;
      var /** @type {string} */ value = org.apache.royale.utils.Language.string(options[flag]);
      if (value != null)
        key += value.toString();
    }
  }
  return key;
};


/**
 *  @asprivate
 * @private
 * @param {Array} a
 * @param {Array} b
 * @param {number} currentDepth
 * @param {number} desiredDepth
 * @param {Object} refs
 * @return {number}
 */
mx.utils.ObjectUtil.arrayCompare = function(a, b, currentDepth, desiredDepth, refs) {
  var /** @type {number} */ result = 0;
  if (a.length != b.length) {
    if (a.length < b.length)
      result = -1;
    else
      result = 1;
  } else {
    var /** @type {Object} */ key;
    for (key in a) {
      if (b.hasOwnProperty(key)) {
        result = mx.utils.ObjectUtil.internalCompare(a[key], b[key], currentDepth, desiredDepth, refs);
        if (result != 0)
          return result;
      } else {
        return -1;
      }
    }
    for (key in b) {
      if (!a.hasOwnProperty(key)) {
        return 1;
      }
    }
  }
  return result;
};


/**
 * @private
 * @param {org.apache.royale.utils.BinaryData} a
 * @param {org.apache.royale.utils.BinaryData} b
 * @return {number}
 */
mx.utils.ObjectUtil.byteArrayCompare = function(a, b) {
  var /** @type {number} */ result = 0;
  if (a == b)
    return result;
  if (a.length != b.length) {
    if (a.length < b.length)
      result = -1;
    else
      result = 1;
  } else {
    for (var /** @type {number} */ i = 0; i < a.length; i++) {
      result = mx.utils.ObjectUtil.numericCompare(a.readByteAt((i) >>> 0), b.readByteAt((i) >>> 0));
      if (result != 0) {
        i = a.length;
      }
    }
  }
  return result;
};


/**
 *  @asprivate
 * @private
 * @param {mx.collections.IList} a
 * @param {mx.collections.IList} b
 * @param {number} currentDepth
 * @param {number} desiredDepth
 * @param {Object} refs
 * @return {number}
 */
mx.utils.ObjectUtil.listCompare = function(a, b, currentDepth, desiredDepth, refs) {
  var /** @type {number} */ result = 0;
  if (a.length != b.length) {
    if (a.length < b.length)
      result = -1;
    else
      result = 1;
  } else {
    for (var /** @type {number} */ i = 0; i < a.length; i++) {
      result = mx.utils.ObjectUtil.internalCompare(a.getItemAt(i), b.getItemAt(i), (currentDepth + 1) >> 0, desiredDepth, refs);
      if (result != 0) {
        i = a.length;
      }
    }
  }
  return result;
};


/**
 * @asprivate
 * This is the "find" for our union-find algorithm when doing object searches.
 * The dictionary keeps track of sets of equal objects
 *
 * @royaleignorecoercion WeakMap
 * @private
 * @param {Object} o
 * @param {Object} refs
 * @return {Object}
 */
mx.utils.ObjectUtil.getRef = function(o, refs) {
  
  var /** @type {WeakMap} */ map = refs;
  var /** @type {Object} */ oRef = map.get(o);
  while (oRef && oRef != map.get(oRef)) {
    oRef = map.get(oRef);
  }
  if (!oRef)
    oRef = o;
  if (oRef != map.get(o))
    map.set(o, oRef);
  return oRef;
};


/**
 * @private
 * @type {number}
 */
mx.utils.ObjectUtil.refCount = 0;


/**
 * @private
 * @type {Object}
 */
mx.utils.ObjectUtil.CLASS_INFO_CACHE = {};


/**
 * @constructor
 */
mx.utils.ObjectUtil.ClassInfo = function() {
  this.ClassInfo__obj = {};
};


/**
 * @private
 * @type {Object}
 */
mx.utils.ObjectUtil.ClassInfo.prototype.ClassInfo__obj;


/**
 * @return {Object}
 */
mx.utils.ObjectUtil.ClassInfo.prototype.toJSON = function() {
  return this.ClassInfo__obj;
};


mx.utils.ObjectUtil.ClassInfo.prototype.get__name = function() {
  return org.apache.royale.utils.Language.string(this.ClassInfo__obj['name']);
};


mx.utils.ObjectUtil.ClassInfo.prototype.set__name = function(value) {
  this.ClassInfo__obj['name'] = value;
};


mx.utils.ObjectUtil.ClassInfo.prototype.get__alias = function() {
  return org.apache.royale.utils.Language.string(this.ClassInfo__obj['alias']);
};


mx.utils.ObjectUtil.ClassInfo.prototype.set__alias = function(value) {
  this.ClassInfo__obj['alias'] = value;
};


mx.utils.ObjectUtil.ClassInfo.prototype.get__properties = function() {
  return this.ClassInfo__obj['properties'];
};


mx.utils.ObjectUtil.ClassInfo.prototype.set__properties = function(value) {
  this.ClassInfo__obj['properties'] = value;
};


mx.utils.ObjectUtil.ClassInfo.prototype.get__dynamic = function() {
  return !!(this.ClassInfo__obj['dynamic']);
};


mx.utils.ObjectUtil.ClassInfo.prototype.set__dynamic = function(value) {
  this.ClassInfo__obj['dynamic'] = value;
};


mx.utils.ObjectUtil.ClassInfo.prototype.get__metadata = function() {
  return this.ClassInfo__obj['metadata'];
};


mx.utils.ObjectUtil.ClassInfo.prototype.set__metadata = function(value) {
  this.ClassInfo__obj['metadata'] = value;
};


Object.defineProperties(mx.utils.ObjectUtil.ClassInfo.prototype, /** @lends {mx.utils.ObjectUtil.ClassInfo.prototype} */ {
/**
  * @type {string} */
name: {
get: mx.utils.ObjectUtil.ClassInfo.prototype.get__name,
set: mx.utils.ObjectUtil.ClassInfo.prototype.set__name},
/**
  * @type {string} */
alias: {
get: mx.utils.ObjectUtil.ClassInfo.prototype.get__alias,
set: mx.utils.ObjectUtil.ClassInfo.prototype.set__alias},
/**
  * @type {Array} */
properties: {
get: mx.utils.ObjectUtil.ClassInfo.prototype.get__properties,
set: mx.utils.ObjectUtil.ClassInfo.prototype.set__properties},
/**
  * @type {boolean} */
dynamic: {
get: mx.utils.ObjectUtil.ClassInfo.prototype.get__dynamic,
set: mx.utils.ObjectUtil.ClassInfo.prototype.set__dynamic},
/**
  * @type {Object} */
metadata: {
get: mx.utils.ObjectUtil.ClassInfo.prototype.get__metadata,
set: mx.utils.ObjectUtil.ClassInfo.prototype.set__metadata}}
);
